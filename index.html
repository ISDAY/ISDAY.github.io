
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>ISDAY</title>
        <meta name="author" content="ISDAY">
        <meta name="description" content="">
        <meta name="keywords" content="">
        <link rel="icon" href="avatar/avatar.png">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">ISDAY</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;ISDAY</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(home.jpg)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>ISDAY</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class="">
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/09/18/Typora破解/">
        <h2 class="post-title">Typora破解</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/工具/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                工具
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="Typora破解"><a href="#Typora破解" class="headerlink" title="Typora破解"></a>Typora破解</h1><ol>
<li><p>下载Typora(我的版本为)<img src="C:\Users\12795\AppData\Roaming\Typora\typora-user-images\image-20220625111147753.png" alt="image-20220625111147753"></p>
</li>
<li><p>将文件夹中的app.asar<strong>复制到Typora中的下载目录中的</strong>resources<strong>中，将</strong>resources<strong>中的</strong>app.asar**</p>
<p>替换</p>
</li>
<li><p>打开<strong>Typora</strong>输入邮箱和序列号</p>
<pre><code>邮箱随便填
序列号：
JCEKRV-4V7ZSU-PSQKQ7-G2NT2Q
</code></pre>
</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/Typora破解/" style="color: #ffa2c4">
                Typora破解
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/Typora破解/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/18/springboot-05/">
        <h2 class="post-title">Springboot-05-Mybatis</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/SSM/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                SSM
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>springboot-05-mybatis </p>
<blockquote>
<p>bean</p>
</blockquote>
<pre><code>public class Booksinformation &#123;

    private int id;
    private String name;
    private String author;
    private String press;
    private String type;

&#125;
</code></pre>
<blockquote>
<p>mapper</p>
</blockquote>
<pre><code>@Mapper
@Repository
public interface BooksinformationMapper &#123;

    List&lt;Booksinformation&gt; queryAllBooksinformation();

    Booksinformation queryBooksinformationById(@Param(&quot;id&quot;) int id);

    int addBooksinformation(@Param(&quot;booksinformation&quot;) Booksinformation booksinformation);

    int updateBooksinformation(@Param(&quot;booksinformation&quot;) Booksinformation booksinformation);

    int deleteBooksinformation(@Param(&quot;id&quot;) int id);

&#125;
</code></pre>
<blockquote>
<p>service</p>
</blockquote>
<pre><code>public interface BooksinformationService &#123;

    List&lt;Booksinformation&gt; queryAllBooksinformation();

    Booksinformation queryBooksinformationById(int id);

    int addBooksinformation(Booksinformation booksinformation);

    int updateBooksinformation(Booksinformation booksinformation);

    int deleteBooksinformation(int id);

&#125;
</code></pre>
<blockquote>
<p>serviceImpl</p>
</blockquote>
<pre><code>@Service
public class BooksinformationServiceImpl implements BooksinformationService &#123;

    @Autowired
    private BooksinformationMapper booksinformationMapper;


    public void setBooksinformationMapper(BooksinformationMapper booksinformationMapper) &#123;
        this.booksinformationMapper = booksinformationMapper;
    &#125;

    @Override
    public List&lt;Booksinformation&gt; queryAllBooksinformation() &#123;
        return booksinformationMapper.queryAllBooksinformation();
    &#125;

    @Override
    public Booksinformation queryBooksinformationById(int id) &#123;
        return booksinformationMapper.queryBooksinformationById(id);
    &#125;

    @Override
    public int addBooksinformation(Booksinformation booksinformation) &#123;
        return booksinformationMapper.addBooksinformation(booksinformation);
    &#125;

    @Override
    public int updateBooksinformation(Booksinformation booksinformation) &#123;
        return booksinformationMapper.updateBooksinformation(booksinformation);
    &#125;

    @Override
    public int deleteBooksinformation(int id) &#123;
        return booksinformationMapper.deleteBooksinformation(id);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>controller</p>
</blockquote>
<pre><code>@RestController
public class BooksinformationController &#123;

    @Autowired
    private BooksinformationService booksinformationService;

    @RequestMapping(&quot;/1&quot;)
    public List&lt;Booksinformation&gt; queryAllBooksinformation()&#123;
        List&lt;Booksinformation&gt; list = booksinformationService.queryAllBooksinformation();
        for (Booksinformation book: list) &#123;
            System.out.println(book);
        &#125;
        return list;
    &#125;

    @RequestMapping(&quot;&quot;)
    public String queryBooksinformationById()&#123;
        return null;
    &#125;

    @RequestMapping(&quot;&quot;)
    public String addBooksinformation()&#123;
        return null;
    &#125;

    @RequestMapping(&quot;&quot;)
    public String updateBooksinformation()&#123;
        return null;
    &#125;

    @RequestMapping(&quot;&quot;)
    public String deleteBooksinformation()&#123;
        return null;
    &#125;


&#125;
</code></pre>
<blockquote>
<p>mapper.xml</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--
    mapper映射文件：用于定制sql语句与指定接口中指定方法的映射
    属性namespace：编写接口的全类名，就是告诉MyBatis这个mapper映射文件和哪个接口映射
--&gt;
&lt;mapper namespace=&quot;com.cccrt6.mapper.BooksinformationMapper&quot;&gt;


    &lt;select id=&quot;queryAllBooksinformation&quot; resultType=&quot;Booksinformation&quot;&gt;
        select * from booksinformation
    &lt;/select&gt;

    &lt;select id=&quot;queryBooksinformationById&quot; resultType=&quot;Booksinformation&quot;&gt;
        select * from booksinformation where id = #&#123;id&#125;
    &lt;/select&gt;

    &lt;insert id=&quot;addBooksinformation&quot; parameterType=&quot;Booksinformation&quot;&gt;
        insert into booksinformation values (#&#123;id&#125;,#&#123;name&#125;,#&#123;author&#125;,#&#123;press&#125;,#&#123;type&#125;)
    &lt;/insert&gt;

    &lt;update id=&quot;updateBooksinformation&quot; parameterType=&quot;Booksinformation&quot;&gt;
        update booksinformation set name = #&#123;name&#125;,author = #&#123;author&#125;,press = #&#123;press&#125;,type = #&#123;type&#125; where id= #&#123;id&#125;
    &lt;/update&gt;

    &lt;delete id=&quot;deleteBooksinformation&quot; parameterType=&quot;int&quot;&gt;
        delete from booksinformation where id = #&#123;id&#125;
    &lt;/delete&gt;

&lt;/mapper&gt;

</code></pre>
<pre><code># 数据库驱动：
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
# 数据源名称
spring.datasource.name=defaultDataSource
# 数据库连接地址
spring.datasource.url=jdbc:mysql://localhost:3306/bookshop?serverTimezone=UTC&amp;characterEncoding=utf-8&amp;useUnicode=true
# 数据库用户名&amp;密码：
spring.datasource.username=root
spring.datasource.password=mysql0917

#整合mybatis
mybatis.type-aliases-package=com.cccrt6.bean
mybatis.mapper-locations=classpath:mybatis/mapper/*.xml
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #ff7d73">
                SSM
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Spring/" style="color: #ffa2c4">
                Spring
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/springboot-05/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/18/集合/">
        <h2 class="post-title">集合</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Java/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                Java
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="1-1-1、认识集合"><a href="#1-1-1、认识集合" class="headerlink" title="1.1.1、认识集合"></a>1.1.1、认识集合</h3><ul>
<li>java的集合类主要有&#x3D;&#x3D;<strong>Map</strong>&#x3D;&#x3D;接口和&#x3D;&#x3D;<strong>Collection</strong>&#x3D;&#x3D;接口派生而来的，</li>
</ul>
<ol>
<li>其中&#x3D;&#x3D;<strong>Collection</strong>&#x3D;&#x3D;接口有两个常用的子接口，即**&#x3D;&#x3D;List(有序可重复)&#x3D;&#x3D;**接口和&#x3D;&#x3D;<strong>Set(无序不可重复)</strong>&#x3D;&#x3D;接口</li>
<li>&#x3D;&#x3D;<strong>Map</strong>&#x3D;&#x3D;中有&#x3D;&#x3D;<strong>HashMap</strong>&#x3D;&#x3D;和&#x3D;&#x3D;<strong>TreeMap</strong>&#x3D;&#x3D;<ul>
<li><strong>&#x3D;&#x3D;HashMap&#x3D;&#x3D;</strong><ul>
<li><strong>&#x3D;&#x3D;JDK1.7 : 数组+单线链表&#x3D;&#x3D;</strong></li>
<li>&#x3D;&#x3D;<strong>JDK1.7 : 数组+单线链表 + 红黑树</strong>&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="/assets/%E9%9B%86%E5%90%88/image-20220809102708979.png" alt="image-20220809102708979"></p>
<h3 id="1-1-2、List接口"><a href="#1-1-2、List接口" class="headerlink" title="1.1.2、List接口"></a>1.1.2、List接口</h3><ul>
<li>&#x3D;&#x3D;<strong>List集合：有序集合；可以储存一组不唯一、有序的对象</strong>&#x3D;&#x3D;</li>
</ul>
<h4 id="1、-使用ArrayList类动态存储数据-重点"><a href="#1、-使用ArrayList类动态存储数据-重点" class="headerlink" title="1、 使用ArrayList类动态存储数据(重点)"></a><strong>1、 使用ArrayList类动态存储数据(重点)</strong></h4><ol>
<li><strong>ArrayList 为动态数组</strong>（实现了长度可变的数组）</li>
<li>**ArrayList集合中可以&#x3D;&#x3D;添加任何类型的数据&#x3D;&#x3D;，并且添加的数据都将&#x3D;&#x3D;转换成Object类型&#x3D;&#x3D; **</li>
<li>&#x3D;&#x3D;<strong>ArrayList可以存储NULL</strong>&#x3D;&#x3D;</li>
<li><strong>查询数据快。</strong></li>
</ol>
<p><img src="/assets/%E9%9B%86%E5%90%88/image-20220809111149293.png" alt="image-20220809111149293"></p>
<h4 id="x3D-x3D-ArrayList常用方法-x3D-x3D"><a href="#x3D-x3D-ArrayList常用方法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;ArrayList常用方法&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;ArrayList常用方法&#x3D;&#x3D;</strong></h4><table>
<thead>
<tr>
<th align="center">方          法</th>
<th align="center">说          明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>boolean add(Object o)</code></td>
<td align="center"><strong>在列表的末尾添加元素o,起始索引位置从0开始</strong></td>
</tr>
<tr>
<td align="center"><code>void add(int index,Object o)</code></td>
<td align="center"><strong>在指定的索引位置添加元素o，索引位置必须介于0和列表中元素个数据之间</strong></td>
</tr>
<tr>
<td align="center"><code>int size()</code></td>
<td align="center"><strong>返回列表中的元素个数</strong></td>
</tr>
<tr>
<td align="center"><code>Object get(int index)</code></td>
<td align="center"><strong>返回指定索引位置处的元素，取出的元素是Object类型，使用前需要进行强制类型转换</strong></td>
</tr>
<tr>
<td align="center"><code>void set(int index,Object obj)</code></td>
<td align="center"><strong>将index索引位置的元素替换为obj元素</strong></td>
</tr>
<tr>
<td align="center"><code>boolean contains(Object o)</code></td>
<td align="center"><strong>判断列表中是否存在指定元素o</strong></td>
</tr>
<tr>
<td align="center"><code>int indexOf(Object obj)</code></td>
<td align="center"><strong>返回元素在集合中出现的索引位置</strong></td>
</tr>
<tr>
<td align="center"><code>boolean remove(Object o)</code></td>
<td align="center"><strong>从列表中删除元素o</strong></td>
</tr>
<tr>
<td align="center"><code>Object remove(int index)</code></td>
<td align="center"><strong>从列表中删除指定位置的元素，起始索引位置从0开始</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>示例1</strong></p>
</blockquote>
<h3 id="2、-使用LinkedList类动态存储数据"><a href="#2、-使用LinkedList类动态存储数据" class="headerlink" title="2、 使用LinkedList类动态存储数据"></a>2、 使用LinkedList类动态存储数据</h3><ol>
<li><strong>LinkedList类采用&#x3D;&#x3D;链表&#x3D;&#x3D;储存方式储存数据</strong></li>
<li><strong>优点：插入、删除元素时效率比较高</strong></li>
<li><strong>缺点：查找效率很低</strong></li>
<li><strong>允许元素值是任何数据，&#x3D;&#x3D;包括NULL&#x3D;&#x3D;</strong></li>
</ol>
<p><img src="/assets/%E9%9B%86%E5%90%88/image-20220809164929313.png" alt="image-20220809164929313"></p>
<h4 id="x3D-x3D-LinkedList类常用方法-x3D-x3D"><a href="#x3D-x3D-LinkedList类常用方法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;LinkedList类常用方法&#x3D;&#x3D;"></a>&#x3D;&#x3D;LinkedList类常用方法&#x3D;&#x3D;</h4><table>
<thead>
<tr>
<th align="center">方          法</th>
<th align="center">说          明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>void addFirst(Object obj)</code></td>
<td align="center"><strong>将指定元素插入到当前集合的首部</strong></td>
</tr>
<tr>
<td align="center"><code>void addLast(Object obj)</code></td>
<td align="center"><strong>将指定元素插入到当前集合的尾部</strong></td>
</tr>
<tr>
<td align="center"><code>Object getFirst()</code></td>
<td align="center"><strong>获取当前集合的第一个元素</strong></td>
</tr>
<tr>
<td align="center"><code>Object getLast()</code></td>
<td align="center"><strong>获取当前集合的最后一个元素</strong></td>
</tr>
<tr>
<td align="center"><code>Object removeFirst()</code></td>
<td align="center"><strong>移除并返回当前集合的第一个元素</strong></td>
</tr>
<tr>
<td align="center"><code>Object removeLast()</code></td>
<td align="center"><strong>移除并返回当前集合的最后一个元素</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>示例</strong></p>
</blockquote>
<h3 id="1-1-3-Set接口"><a href="#1-1-3-Set接口" class="headerlink" title="1.1.3 Set接口"></a>1.1.3 Set接口</h3><h4 id="1、Set接口概述"><a href="#1、Set接口概述" class="headerlink" title="1、Set接口概述"></a>1、Set接口概述</h4><ul>
<li><p><strong>Set接口描述的是一种比较简单的集合</strong></p>
</li>
<li><p><strong>Set接口可以存储一组唯一、无序的对象</strong></p>
</li>
<li><p><strong>Set接口常用的实现类有&#x3D;&#x3D;HashSet&#x3D;&#x3D;和&#x3D;&#x3D;TreeSet&#x3D;&#x3D;</strong></p>
</li>
</ul>
<h4 id="2、使用HashSet类动态储存数据"><a href="#2、使用HashSet类动态储存数据" class="headerlink" title="2、使用HashSet类动态储存数据"></a>2、使用HashSet类动态储存数据</h4>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/集合/" style="color: #00bcd4">
                集合
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/集合/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/18/SSM整合/">
        <h2 class="post-title">SSM整合</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/SSM/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                SSM
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="1-环境要求"><a href="#1-环境要求" class="headerlink" title="1.环境要求"></a><strong>1.环境要求</strong></h1><ul>
<li><p>IDEA</p>
</li>
<li><p>MySQL 5.7</p>
</li>
<li><p>Tomcat 9</p>
</li>
<li><p>Maven 3.6</p>
<p>要求：</p>
</li>
<li><p>需要熟练掌握MySQL数据库，Spring，Java Web及Mybatis知识，简单的前端知识。</p>
</li>
</ul>
<h1 id="2-数据库环境"><a href="#2-数据库环境" class="headerlink" title="2.数据库环境"></a><strong>2.数据库环境</strong></h1><p>创建一个存放书籍数据的数据库表</p>
<pre><code class="sql">CREATE DATABASE `ssmbuild`;
 
USE `ssmbuild`;
 
DROP TABLE IF EXISTS `books`;
 
CREATE TABLE `books` (
  `bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;,
  `bookName` VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;,
  `bookCounts` INT(11) NOT NULL COMMENT &#39;数量&#39;,
  `detail` VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;,
  KEY `bookID` (`bookID`)
) ENGINE=INNODB DEFAULT CHARSET=utf8;
 
INSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES 
(1,&#39;Java&#39;,10,&#39;从入门到放弃&#39;),
(2,&#39;MySQL&#39;,6,&#39;从删库到跑路&#39;),
(3,&#39;Linux&#39;,5,&#39;从入门到进牢&#39;);
</code></pre>
<h1 id="3-基本环境搭建"><a href="#3-基本环境搭建" class="headerlink" title="3.基本环境搭建"></a><strong>3.基本环境搭建</strong></h1><p>1、新建一Maven项目！ssmbuild ， 添加web的支持！</p>
<p>2、导入相关的pom依赖！</p>
<pre><code class="xml">&lt;!--依赖：junit，数据库驱动，连接池，servlet，jsp，Mybatis，Mybatis-Spring，Spring--&gt;
&lt;dependencies&gt;
    &lt;!--junit--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--数据库驱动--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.48&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--c3p0--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.mchange&lt;/groupId&gt;
        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
        &lt;version&gt;0.9.5.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--servlet jsp jstl--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;version&gt;2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--Mybatis--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--Mybatis和Spring整合包--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;2.0.4&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--Spring--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
折叠 
</code></pre>
<p>3.Maven静态资源导出设置</p>
<pre><code class="xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<p>4、建立项目基本结构和配置框架！</p>
<ul>
<li>com.tian.pojo</li>
<li>com.tian.dao</li>
<li>com.tian.service</li>
<li>com.tian.controller</li>
<li>mybatis-config.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
 
&lt;/configuration&gt;
</code></pre>
<ul>
<li>applicationContext.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
 
&lt;/beans&gt;
</code></pre>
<h1 id="4-Mybatis层编写"><a href="#4-Mybatis层编写" class="headerlink" title="4.Mybatis层编写"></a><strong>4.Mybatis层编写</strong></h1><p>1.数据库配置文【database.properties】</p>
<pre><code class="properties">jdbc.driver=com.mysql.jdbc.Driver
# 如果使用的是MySQL8.0+,需要增加一个时区配置 &amp;serverTimezone=Asia/Shanghai
jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=root
</code></pre>
<p>2、IDEA关联数据库</p>
<p>3、编写MyBatis的核心配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;!--配置数据源,交给Spring去做--&gt;

    &lt;!--开启日志--&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
    &lt;/settings&gt;

    &lt;!--配置别名--&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.tian.pojo&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;mappers&gt;
        &lt;mapper class=&quot;com.tian.dao.BookMapper&quot;/&gt;
    &lt;/mappers&gt;

&lt;/configuration&gt;
</code></pre>
<p>4、编写数据库对应的实体类 com.tian.Books</p>
<p>使用lombok插件！</p>
<pre><code class="java">package com.tian.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Books &#123;
    private int bookID;
    private String bookName;
    private int bookCounts;
    private String detail;
&#125;
</code></pre>
<p>5、编写Dao层的 Mapper接口！</p>
<pre><code class="java">package com.tian.dao;

import com.tian.pojo.Books;

import java.util.List;

public interface BookMapper &#123;
    //增加一个Book
    int addBook(Books book);

    //根据id删除一个Book
    int deleteBookById(int id);

    //更新Book
    int updateBook(Books books);

    //根据id查询,返回一个Book
    Books queryBookById(int id);

    //查询全部Book,返回list集合
    List&lt;Books&gt; queryAllBook();
&#125;
</code></pre>
<p>6、编写接口对应的 Mapper.xml 文件。</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.tian.dao.BookMapper&quot;&gt;
    &lt;!--增加一个Book--&gt;
    &lt;insert id=&quot;addBook&quot; parameterType=&quot;books&quot;&gt;
        insert into ssmbuild.books (bookName, bookCounts, detail) values (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;)
    &lt;/insert&gt;
    &lt;!--根据id删除一个Book--&gt;
    &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt;
        delete from ssmbuild.books where bookID=#&#123;bookID&#125;
    &lt;/delete&gt;
    &lt;!--更新Book--&gt;
    &lt;update id=&quot;updateBook&quot; parameterType=&quot;books&quot;&gt;
        update ssmbuild.books set bookName = #&#123;bookName&#125;,bookCounts = #&#123;bookCounts&#125;,detail = #&#123;detail&#125;
        where bookID = #&#123;bookID&#125;
    &lt;/update&gt;
    &lt;!--根据id查询,返回一个Book--&gt;
    &lt;select id=&quot;queryBookById&quot; parameterType=&quot;int&quot; resultType=&quot;books&quot;&gt;
        select * from ssmbuild.books where bookID=#&#123;bookID&#125;
    &lt;/select&gt;
    &lt;!--查询全部Book,返回list集合--&gt;
    &lt;select id=&quot;queryAllBook&quot; resultType=&quot;books&quot;&gt;
        select * from ssmbuild.books
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>7、编写Service层的接口和实现类</p>
<p>接口：</p>
<pre><code class="java">//BookService:底下需要去实现,调用dao层
public interface BookService &#123;
    //增加一个Book
    int addBook(Books book);

    //根据id删除一个Book
    int deleteBookById(@Param(&quot;bookID&quot;) int id);

    //更新Book
    int updateBook(Books books);

    //根据id查询,返回一个Book
    Books queryBookById(@Param(&quot;bookID&quot;) int id);

    //查询全部Book,返回list集合
    List&lt;Books&gt; queryAllBook();
&#125;
</code></pre>
<p>实现类：</p>
<pre><code class="java">public class BookServiceImpl implements BookService&#123;

    //调用dao层的操作，设置一个set接口，方便Spring管理
    private BookMapper bookMapper;

    public void setBookMapper(BookMapper bookMapper) &#123;
        this.bookMapper = bookMapper;
    &#125;

    @Override
    public int addBook(Books book) &#123;
        return bookMapper.addBook(book);
    &#125;

    @Override
    public int deleteBookById(int id) &#123;
        return bookMapper.deleteBookById(id);
    &#125;

    @Override
    public int updateBook(Books books) &#123;
        return bookMapper.updateBook(books);
    &#125;

    @Override
    public Books queryBookById(int id) &#123;
        return bookMapper.queryBookById(id);
    &#125;

    @Override
    public List&lt;Books&gt; queryAllBook() &#123;
        return bookMapper.queryAllBook();
    &#125;
&#125;
</code></pre>
<p><strong>OK，到此，底层需求操作编写完毕！</strong></p>
<h1 id="5-Spring层"><a href="#5-Spring层" class="headerlink" title="5.Spring层"></a><strong>5.Spring层</strong></h1><p>1、配置<strong>Spring整合MyBatis</strong>，我们这里数据源使用c3p0连接池；</p>
<p>2、我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--整合Mybatis--&gt;
    &lt;!-- 1.关联数据库配置文件--&gt;
    &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;

    &lt;!-- 2.数据库连接池--&gt;
    &lt;!--数据库连接池
        dbcp  半自动化操作  不能自动连接
        c3p0  自动化操作（自动的加载配置文件 并且设置到对象里面）
    --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;!--配置连接池属性--&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;

        &lt;!--c3p0连接池私有属性--&gt;
        &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;
        &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;
        &lt;!-- 关闭连接后不自动commit --&gt;
        &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;
        &lt;!-- 获取连接超时时间 --&gt;
        &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;
        &lt;!-- 当获取连接失败重试次数 --&gt;
        &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 3.配置SqlSessionFactory对象--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;!--注入数据库连接池--&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!-- 配置Mybatis全局配置文件:mybatis-config.xml --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 4.配置扫描Dao接口包,动态实现Dao接口注入到spring容器中--&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;!--注入SqlSessionFactory--&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
        &lt;!--指定需要扫描的Dao接口包--&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.tian.dao&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
折叠 
</code></pre>
<p>3、<strong>Spring整合service层</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--扫描service包下相关的bean--&gt;
    &lt;context:component-scan base-package=&quot;com.tian.service&quot;/&gt;

    &lt;!--将所有业务类注入到spring容器托管,可以通过配置或者注解实现--&gt;
    &lt;bean id=&quot;bookService&quot; class=&quot;com.tian.service.BookServiceImpl&quot;&gt;
        &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置事务管理器--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!-- 注入数据库连接池 --&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！</p>
<h1 id="6-SpringMVC层"><a href="#6-SpringMVC层" class="headerlink" title="6.SpringMVC层"></a><strong>6.SpringMVC层</strong></h1><p><strong>1.web.xml</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--配置DispatcherServlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;!--一定要注意:我们这里加载的是总的配置文件，这里有坑！--&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;!--EncodingFilter--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!--Session过期时间--&gt;
    &lt;session-config&gt;
        &lt;session-timeout&gt;15&lt;/session-timeout&gt;
    &lt;/session-config&gt;
&lt;/web-app&gt;
折叠 
</code></pre>
<p><strong>2.spring-mvc.xml</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!--配置SpringMVC--&gt;
    &lt;!-- 1.开启SpringMVC注解驱动--&gt;
    &lt;mvc:annotation-driven/&gt;

    &lt;!-- 2.静态资源过滤--&gt;
    &lt;mvc:default-servlet-handler/&gt;

    &lt;!-- 3.配置视图解析器--&gt;
    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;!--前缀--&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
        &lt;!--后缀--&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 4.扫描controller包下相关的bean--&gt;
    &lt;context:component-scan base-package=&quot;com.tian.controller&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p>3、<strong>Spring配置整合文件，applicationContext.xml</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-mvc.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>到此，配置文件结束！</strong></p>
<h1 id="7-Controller和视图层编写"><a href="#7-Controller和视图层编写" class="headerlink" title="7.Controller和视图层编写"></a><strong>7.Controller和视图层编写</strong></h1><p>1.BookController类编写 方法一：查询全部书籍</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/book&quot;)
public class BookController &#123;

    @Autowired
    @Qualifier(&quot;bookServiceImpl&quot;)
    private BookService bookService;

    //方法一:查询全部书籍
    @RequestMapping(&quot;/allBook&quot;)
    public String list(Model model)&#123;
        List&lt;Books&gt; books = bookService.queryAllBook();
        model.addAttribute(&quot;list&quot;,books);
        return &quot;allBook&quot;;
    &#125;
&#125;
</code></pre>
<p>2、编写首页 <strong>index.jsp</strong></p>
<pre><code class="jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;首页&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            a &#123;
                text-decoration: none;
                color: black;
                font-size: 18px;
            &#125;
            h3 &#123;
                width: 180px;
                height: 38px;
                margin: 100px auto;
                text-align: center;
                line-height: 38px;
                background: deepskyblue;
                border-radius: 4px;
            &#125;
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h3&gt;
            &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;&gt;点击进入列表页&lt;/a&gt;
        &lt;/h3&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3、书籍列表页面 <strong>allbook.jsp</strong></p>
<pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;书籍列表&lt;/title&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
        &lt;!-- 引入 Bootstrap --&gt;
        &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;div class=&quot;container&quot;&gt;
            &lt;div class=&quot;row clearfix&quot;&gt;
                &lt;div class=&quot;col-md-12 column&quot;&gt;
                    &lt;div class=&quot;page-header&quot;&gt;
                        &lt;h1&gt;
                            &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;
                        &lt;/h1&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-md-4 column&quot;&gt;
                    &lt;a class=&quot;btn btn-primary&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;&gt;新增&lt;/a&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;row clearfix&quot;&gt;
                &lt;div class=&quot;col-md-12 column&quot;&gt;
                    &lt;table class=&quot;table table-hover table-striped&quot;&gt;
                        &lt;thead&gt;
                            &lt;tr&gt;
                                &lt;th&gt;书籍编号&lt;/th&gt;
                                &lt;th&gt;书籍名字&lt;/th&gt;
                                &lt;th&gt;书籍数量&lt;/th&gt;
                                &lt;th&gt;书籍详情&lt;/th&gt;
                                &lt;th&gt;操作&lt;/th&gt;
                            &lt;/tr&gt;
                        &lt;/thead&gt;
                        &lt;tbody&gt;
                            &lt;c:forEach var=&quot;book&quot; items=&quot;$&#123;requestScope.get(&#39;list&#39;)&#125;&quot;&gt;
                                &lt;tr&gt;
                                    &lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt;
                                    &lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt;
                                    &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt;
                                    &lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt;
                                    &lt;td&gt;
                                        &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;/a&gt; |
                                        &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;/a&gt;
                                    &lt;/td&gt;
                                &lt;/tr&gt;
                            &lt;/c:forEach&gt;
                        &lt;/tbody&gt;
                    &lt;/table&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
折叠 
</code></pre>
<p>BookController 类编写 方法二：添加书籍</p>
<pre><code class="java">@RequestMapping(&quot;/toaddBook&quot;)
public String toAddPaper()&#123;
    return &quot;addBook&quot;;
&#125;

//方法二：添加书籍
@RequestMapping(&quot;/addBook&quot;)
public String addBook(Books book)&#123;
    bookService.addBook(book);
    return &quot;redirect:/book/allBook&quot;;
&#125;
</code></pre>
<p>5、添加书籍页面：<strong>addBook.jsp</strong></p>
<pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
 
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;新增书籍&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;!-- 引入 Bootstrap --&gt;
    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row clearfix&quot;&gt;
        &lt;div class=&quot;col-md-12 column&quot;&gt;
            &lt;div class=&quot;page-header&quot;&gt;
                &lt;h1&gt;
                    &lt;small&gt;新增书籍&lt;/small&gt;
                &lt;/h1&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/addBook&quot; method=&quot;post&quot;&gt;
        书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
        书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
        书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p>6、BookController 类编写 ， 方法三：修改书籍</p>
<pre><code class="java">//方法三：修改书籍信息
@RequestMapping(&quot;/toUpdateBook&quot;)
public String toUpdateBook(Model model,int id)&#123;
    Books book = bookService.queryBookById(id);
    model.addAttribute(&quot;book&quot;,book);
    return &quot;updateBook&quot;;
&#125;

@RequestMapping(&quot;/updateBook&quot;)
public String updateBook(Model model,Books book)&#123;
    bookService.updateBook(book);
    Books books = bookService.queryBookById(book.getBookID());
    model.addAttribute(&quot;books&quot;, books);
    return &quot;redirect:/book/allBook&quot;;
&#125;
</code></pre>
<p>7、修改书籍页面 <strong>updateBook.jsp</strong></p>
<pre><code class="jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;

&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;修改书籍信息&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;!-- 引入 Bootstrap --&gt;
    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;row clearfix&quot;&gt;
        &lt;div class=&quot;col-md-12 column&quot;&gt;
            &lt;div class=&quot;page-header&quot;&gt;
                &lt;h1&gt;
                    &lt;small&gt;修改书籍信息&lt;/small&gt;
                &lt;/h1&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/updateBook&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;bookID&quot; value=&quot;$&#123;book.bookID&#125;&quot;/&gt;
        书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot; value=&quot;$&#123;book.bookName&#125;&quot;/&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
        书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot; value=&quot;$&#123;book.bookCounts&#125;&quot;/&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
        书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot; value=&quot;$&#123;book.detail&#125;&quot;/&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p>8、BookController 类编写 方法四：删除书籍</p>
<pre><code class="java">//方法四：删除书籍【使用restFul风格】
@RequestMapping(&quot;/del/&#123;bookID&#125;&quot;)
public String deleteBook(@PathVariable(&quot;bookID&quot;) int id)&#123;
    bookService.deleteBookById(id);
    return &quot;redirect:/book/allBook&quot;;
&#125;
</code></pre>
<p><strong>配置Tomcat，进行运行！</strong></p>
<p>到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，大家需要保证，不看任何东西，自己也可以完整的实现出来！</p>
<p><strong>项目结构图</strong><br><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2276380-20210301135520867-439800185.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2276380-20210301135531280-1900947734.png" alt="img"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #03a9f4">
                SSM
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/SSM整合/" style="color: #ff7d73">
                SSM整合
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/SSM整合/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/18/MyBatis/">
        <h2 class="post-title">MyBatis</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/SSM/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                SSM
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="1、搭建数据库"><a href="#1、搭建数据库" class="headerlink" title="1、搭建数据库"></a>1、搭建数据库</h2><pre><code class="sql">CREATE DATABASE `mybatis`;

USE `mybatis`;

CREATE TABLE `user`(
    `id` INT(20) NOT NULL PRIMARY KEY,
    `name` VARCHAR(30) DEFAULT NULL,
    `pwd` VARCHAR(30) DEFAULT NULL
)ENGINE=INNODB DEFAULT charset=utf8;

INSERT INTO `user` (`id`,`name`,`pwd`) VALUES
(1,&#39;root1&#39;,&#39;12345601&#39;),
(2,&#39;root2&#39;,&#39;12345602&#39;),
(3,&#39;root3&#39;,&#39;12345603&#39;),
(4,&#39;root4&#39;,&#39;12345604&#39;);
</code></pre>
<h2 id="2、新建项目"><a href="#2、新建项目" class="headerlink" title="2、新建项目"></a>2、新建项目</h2><ul>
<li><strong>文件目录</strong></li>
<li><img src="/assets/MyBatis/image-20220630093620534-16570249709591.png" alt="image-20220630093620534"></li>
</ul>
<ol>
<li><p><strong>导入依赖</strong>(在pom.xml中添加依赖)</p>
<ul>
<li><pre><code class="xml">&lt;!--    导入依赖--&gt;
    &lt;dependencies&gt;
&lt;!--    mysql依赖--&gt;
        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.28&lt;/version&gt;
        &lt;/dependency&gt;

&lt;!--        mybatis核心包--&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.6&lt;/version&gt;
        &lt;/dependency&gt;

&lt;!--   测试     junit--&gt;
        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13.1&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>添加工具类【MybatisUtils.java】</strong></p>
<ul>
<li><pre><code class="java"> private static SqlSessionFactory build;
    
//    使用mybatis第一步
//    获取sqlSessionFactory对象
    static &#123;
        try &#123;
            String resource = &quot;mybatis-config.xml&quot;;
            InputStream resourceAsStream = Resources.getResourceAsStream(resource);
            build = new SqlSessionFactoryBuilder().build(resourceAsStream);
        &#125; catch (IOException e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
//        既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。
//        SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。
    public static SqlSession getSqlSession()&#123;
        return build.openSession();

    &#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>在静态文件夹【resuorces】文件夹中新建【mybatis-config.xml】配置文件</strong></p>
<p><strong>每创建一个xxMapper.xml都要在<mappers>中添加一个mapper</strong></p>
<ul>
<li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;

&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?   	serverTimezone=GMT&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;mysql0917&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;mappers&gt;
        &lt;mapper class=&quot;com.ccrt6.mapper.UserMapper&quot;&gt;&lt;/mapper&gt;
    &lt;/mappers&gt;


&lt;/configuration&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>构建实体类，在main-&gt;java-&gt;下建立com.ccrt6.bean-&gt;在bean文件夹中新建-&gt;Userinfo.java</strong></p>
<ul>
<li><pre><code class="java">package com.ccrt6.bean;

/**
 * @author zh
 * @Title:Userinfo
 * @Package:com.ccrt6.bean
 * @Description:实体类
 * @date 2022/6/2818:45
 */
public class Userinfo &#123;
    // 属性名和数据表的字段名保持一致
    private int id;
    private String name;
    private String ped;
    // 快捷键生成构造器、get、set方法：alt+insert
    public Userinfo() &#123;
    &#125;

    public Userinfo(int id, String name, String ped) &#123;
        this.id = id;
        this.name = name;
        this.ped = ped;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getPed() &#123;
        return ped;
    &#125;

    public void setPed(String ped) &#123;
        this.ped = ped;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Userinfo&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, ped=&#39;&quot; + ped + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>创建mapper接口，在com.ccrt6-&gt;新建mapper文件夹-&gt;在mapper文件夹中新建UserMapper接口</strong></p>
<ul>
<li><pre><code class="java">package com.ccrt6.mapper;

import com.ccrt6.bean.Userinfo;

/**
 * @author zh
 * @Title: mapper
 * @Package com.ccrt6.mapper
 * @Description:接口
 * @date 2022/6/28/20:32
 */
public interface UserMapper &#123;
    /**
     * 通过id查询指定的用户信息
     * @param id
     * @return
     */
    Userinfo findUserById(int id);
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>编写我们自己的mapper映射文件</strong></p>
<p><strong>在静态文件夹【resuorces】文件夹中新建-&gt;com.ccrt6.mapper-&gt;创建UserMapper.xml</strong></p>
<ul>
<li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--
    mapper映射文件：用于定制sql语句与指定接口中指定方法的映射
    属性namespace：编写接口的全类名，就是告诉MyBatis这个mapper映射文件和哪个接口映射 
--&gt;
&lt;mapper namespace=&quot;com.ccrt6.mapper.UserMapper&quot;&gt;
    &lt;!-- 在这里面编写 sql语句 与 接口方法 的映射 --&gt;
    
    &lt;!--&lt;select&gt;：表示这个操作是一个查询操作
         属性id：表示的是要匹配的接口方法的名称
         属性resultType：表示返回值的类型，对应接口方法的返回值类型。
             查询操作完成后，mybatis会根据返回值类型，将数据封装成指定的对象。
             这个步骤和jdbc中：根据结果集ResultSet中的数据封装成指定的对象 是一样的。
         #&#123;属性名&#125;：获取接口中方法传递的实参，这里的属性名和接口方法的形参名保持一致，
         否则就需要 进行其他的设置（后面会讲）。 
       --&gt;

    &lt;select id=&quot;findUserById&quot; resultType=&quot;com.ccrt6.bean.Userinfo&quot;&gt;
        select * from user where id = #&#123;id&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p><strong>静态文件中创建的com.ccrt6.mapper要与在src-&gt;main中创建的一致，在resources中创建mapper映射文件</strong></p>
<p><strong>运行后会在target文件夹中自动生成</strong></p>
<p><strong>【如果将映射文件放在src-&gt;main中运行后在target文件夹中则不会自动生成，会报错，因为运行的是target下的文件】</strong></p>
<p><strong>为什么这里要这么做？其实这里存放mapper映射文件的方式主要有两种</strong></p>
<p><strong>（1）将mapper映射文件和mapper接口放在同一个包下，但是maven不会编译java文件夹下的</strong></p>
<p><strong>xml类型的静态资源文件，这样的话，一运行就会报错。解决方案：就是在pom.xml文件中，添加</strong></p>
<p><strong>一个编译静态资源的插件，代码如下:</strong></p>
<pre><code class="xml">&lt;build&gt; 
    &lt;resources&gt; 
        &lt;resource&gt; 
            &lt;directory&gt;src/main/java&lt;/directory&gt; 
            &lt;includes&gt; 
            &lt;include&gt;**/*.xml&lt;/include&gt; 
            &lt;/includes&gt; 
        &lt;/resource&gt; 
    &lt;/resources&gt; 
&lt;/build&gt;
</code></pre>
<p><strong>（2）由于resources文件才是存放 静态资源的地方，所以我们可以在该文件下建立 同包名的文件</strong></p>
<p><strong>夹，将xml等资源文件放置到这个目录中。maven工具默认在编译的时候，会将 该文件夹中的资</strong></p>
<p><strong>源文件 和 同包名中java文件 一块编译在同一个文件夹中。</strong></p>
<p><strong>比如：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220630110124983.png" alt="image-20220630110124983"></p>
<p><strong>相比之下，第二种方式比第一种方式要快捷。</strong></p>
</li>
</ul>
</li>
<li><p><strong>在test-&gt;java下新建测试类Usermapper_test.java</strong></p>
<ul>
<li><pre><code class="java">import com.ccrt6.bean.Userinfo;
import com.ccrt6.mapper.UserMapper;
import com.ccrt6.utils.MybatisUtils;
import org.apache.ibatis.session.SqlSession;
import org.junit.Test;

/**
 * @author zh
 * @Title: Usermapper_test
 * @Package com.ccrt6.mapper
 * @Description: Usermapper_test的测试类
 * @date 2022/6/28/20:48
 */
public class Usermapper_test &#123;

    @Test
    public void testFindUserById()&#123;
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        Userinfo userById = mapper.findUserById(1);
        System.out.println(userById);
        sqlSession.close();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h2 id="掌握MyBatis的核心配置文件"><a href="#掌握MyBatis的核心配置文件" class="headerlink" title="掌握MyBatis的核心配置文件"></a><strong>掌握</strong>MyBatis<strong>的核心配置文件</strong></h2><p><strong>在mybatis的项目中，我们发现了有一个mybatis-config.xml的配置文件，这个配置文件是mybatis</strong></p>
<p><strong>的全局配置文件，用来进行相关的全局配置，在任何操作下都生效的配置。下面我们要针对其中的属性</strong></p>
<p><strong>做详细的解释，方便大家在后续使用的时候更加熟练。</strong></p>
<p><strong>先编写一个外部配置文件，用来存储MySQL的连接信息：</strong></p>
<p><strong>在resources新建db.properties</strong></p>
<pre><code class="properties">jdbc.driver=com.mysql.cj.jdbc.Driver 
jdbc.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT&amp;useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=root
</code></pre>
</li>
</ol>
<p>​		<strong>然后我们再来看看配置文件mybatis-config.xml的内容：</strong>		</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; 
&lt;!DOCTYPE configuration 
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; 
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 
&lt;configuration&gt; 

    &lt;!--
        引入外部配置文件 
    --&gt; 
    &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt; 
    
    &lt;!--
        用来控制MyBatis在运行时的行为，是MyBatis中的重要配置 
    --&gt; 
    &lt;settings&gt; 
        &lt;!--
            当 数据表中的字段 在映射时，是否将字段名转化为采用了 驼峰原则的标识符 
            即：将 user_name转换为 userName，这样可以减少resultMap的使用 
            默认为 false，即不转换 
        --&gt; 
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; 
    &lt;/settings&gt; 
    
    &lt;!--
        typeAliases表示为我们引用的实体类起别名，默认情况下我们需要写类的完全限定名 
        如果在此处做了配置，那么可以直接写类的名称 
    --&gt;
    &lt;typeAliases&gt; 
        &lt;!--
        为某一个实体起别名： 
        （1）在type中配置上类的完全限定名，此时类名就是别名，而且别名是可以忽略大小写的。 
        （2）可以通过alias属性来表示类的别名，此时别名就是alias的属性值，不是类名 了！！！ 
            注意：若不使用alias属性起别名，则是第（1）中情况，默认使用类名作为别名。
         --&gt; 
         &lt;typeAlias type=&quot;com.sys.bean.UserInfo&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt; 

         &lt;!--
            若有多个实体类，则可以使用批量起别名的方式（最常用的起别名的方法） 
            属性name：指定包名，代表该包下面的所有类都批量起了别名 
            注意：这里使用类名作为别名 
         --&gt; 
         &lt;package name=&quot;com.sys&quot;/&gt; 
    &lt;/typeAliases&gt; 
    
    &lt;!--
        在实际的开发过程中，我们可能分为开发环境，生产环境，测试环境等等，每个环境的配置可以是 不一样的。
        &lt;environments&gt;：存放各个环境的配置，并使用 属性default 来设置当前的环境。 
    --&gt; 
    &lt;environments default=&quot;development&quot;&gt; 
    &lt;!--
        &lt;environment&gt;：用来表示不同环境的细节配置，每一个环境中都需要一个事务管理器以及数据源的配置 
        我们在后续的项目开发中几乎都是使用spring中配置的数据源和事务管理器来配置，此处不需要研究 
    --&gt; 
    &lt;environment id=&quot;development&quot;&gt; 
        &lt;!--
            &lt;transactionManager&gt;：配置事务管理器，默认采用“JDBC” 
        --&gt; 
        &lt;transactionManager type=&quot;JDBC&quot;/&gt; 
        &lt;!--
            &lt;dataSource&gt;：配置数据源，默认采用“POOLED”(数据库连接池) 
        --&gt; 
        &lt;dataSource type=&quot;POOLED&quot;&gt; 
            &lt;!--
                &lt;property&gt;：配置连接数据库的四个参数 
                由于四个参数的值放在外部配置文件db.properties当中， 
                所以，需要使用 $&#123;属性名&#125; 来引入外部变量 
            --&gt; 
            &lt;!-- 这一项是配置mysql驱动的类路径 --&gt; 
            &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; 
            &lt;!-- 配置mysql的url --&gt; 
            &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; 
            &lt;!-- 配置mysql的账号 --&gt; 
            &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; 
            &lt;!-- 配置mysql的密码（记得使用自己的密码） --&gt; 
            &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; 
        &lt;/dataSource&gt; 
    &lt;/environment&gt; 
&lt;/environments&gt; 
    &lt;!--
        在不同的数据库中，可能sql语句的写法是不一样的，为了增强移植性，可以提供不同数据库的操作实现 
        注意：在编写mapper映射文件中的sql语句时，可以指定databaseId属性来标识当前sql语句可以运行在哪个数据库中
    --&gt; 
    &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt; 
        &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt; 
        &lt;property name=&quot;SQl Server&quot; value=&quot;sqlserver&quot;/&gt; 
        &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&gt; 
    &lt;/databaseIdProvider&gt; 
    
    &lt;!--
        &lt;mappers&gt;：我们需要在该标签中引入每一个Mapper映射文件 
    --&gt; 
    &lt;mappers&gt; 
    &lt;!--
        使用&lt;mapper&gt;引入指定的mapper映射文件 
        resource属性：通过映射文件的 相对的物理路径 引入 
        class属性：通过mapper接口的类路径，间接的引入 
    --&gt; 
&lt;!-- 	&lt;mapper resource=&quot;com/sys/mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt;--&gt; 
&lt;!-- 	&lt;mapper class=&quot;com.sys.mapper.UserMapper&quot;&gt;&lt;/mapper&gt;--&gt; 

    &lt;!--
        当映射文件很多时，使用&lt;mapper&gt;标签一个个引入开会很麻烦，也费时间 
        此时，我们可以使用&lt;package&gt;标签完成批量引入 
        属性name：指定包的类路径 
    --&gt; 
    &lt;package name=&quot;com.sys.mapper&quot;/&gt;
    
    &lt;!--
        关于属性class或者标签&lt;package&gt; 
        原理：
            1、在编译过后，程序开始运行； 
            2、一开始会根据class属性值或者标签&lt;package&gt;中name属性值，获取指定接口的类路径； 
            3、然后根据类路径利用反射，获取mapper接口的名字； 
            4、然后根据mapper接口的名字在同一个文件夹下查找同名的Mapper映射文件，并引入。 
            说明：
                通过上述原理，可知要使用 class属性 和 &lt;package&gt; 标签需要保证，
                mapper接口和mapper映射文件在编译过后，两者位于同一个文件夹下！！！ 
            注意： 
            （1）编译过后，当Mapper映射文件和mapper接口同名，并且在同一文件夹下时，可以使用 
                &lt;mapper&gt;标签的class、resource属性，还可以使用&lt;package&gt;标签进行批量引入。 
            （2）其他情况，只能使用 &lt;mapper&gt;标签的resource属性 
     --&gt; 
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h1 id="备注：快捷键生成相应的代码"><a href="#备注：快捷键生成相应的代码" class="headerlink" title="备注：快捷键生成相应的代码"></a><strong>备注：快捷键生成相应的代码</strong></h1><p><strong>（1）Alt+Insert 快捷键生成 构造器：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220630112704224.png" alt="image-20220630112704224"></p>
<p><strong>（2）Alt+Insert 快捷键生成 get和set方法：</strong></p>
<p><img src="/assets/MyBatis/image-20220630112816424-16570249899333.png" alt="image-20220630112816424"></p>
<p><strong>（3）Alt+Insert 快捷键生成 toStringt方法：</strong></p>
<p><img src="/assets/MyBatis/image-20220630112851257-16570249959615.png" alt="image-20220630112851257"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #03a9f4">
                SSM
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/MyBatis/" style="color: #ff7d73">
                MyBatis
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/MyBatis/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/18/第2章 映射文件详解/">
        <h2 class="post-title">第2章 映射文件详解</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/SSM/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                SSM
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="第2章-映射文件详解"><a href="#第2章-映射文件详解" class="headerlink" title="第2章 映射文件详解"></a>第2章 映射文件详解</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a><span class="underline">引入</span></h2><p>通过前面的学习，我们对MyBatis有了初步认识，MyBatis的三个基本要素：</p>
<p>（1）MyBatis核心的接口和类</p>
<p>（2）MyBatis核心配置文件（mybatis-config.xml）</p>
<p>（3）SQL映射文件（mapper.xml）</p>
<p>MyBatis的核心接口和类、配置文件在前面已经讲解了，那么本章再来详细讲解映射文件。</p>
<p>映射文件中需要掌握的部分就是：常用的元素（标签）、常用元素的属性以及SQL语句。</p>
<p>在映射文件中，可以编写以下的顶级元素标签：</p>
<pre><code class="xml">cache – 该命名空间的缓存配置。

cache-ref – 引用其它命名空间的缓存配置。

resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。

parameterMap – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。

sql – 可被其它语句引用的可重用语句块。

insert – 映射插入语句。

update – 映射更新语句。

delete – 映射删除语句。

select – 映射查询语句。
</code></pre>
<p>在每个顶级元素标签中可以添加很多个属性，具体如下：</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td><code>parameterType</code></td>
<td>将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参 数，默认值为未设置（unset）。</td>
</tr>
<tr>
<td><code>parameterMap</code></td>
<td>用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数 映射和 parameterType 属性。</td>
</tr>
<tr>
<td><code>flushCache</code></td>
<td>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被 清空，默认值：（对 insert、update 和 delete 语句）true。</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。 默认值为未设置（unset）（依赖数据库驱动）。</td>
</tr>
<tr>
<td><code>statementType</code></td>
<td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。 默认值为未设置（unset）（依赖数据库驱动）。</td>
</tr>
<tr>
<td><code>useGeneratedKeys</code></td>
<td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段）， 默认值：false。</td>
</tr>
<tr>
<td><code>keyProperty</code></td>
<td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设 置它的值，默认值：未设置（ unset ）。如果生成列不止一个，可以用逗 号分隔多个属性名称。</td>
</tr>
<tr>
<td><code>keyColumn</code></td>
<td>（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据 库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设 置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td>
</tr>
<tr>
<td><code>databaseId</code></td>
<td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所 有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语 句都有，则不带的会被忽略</td>
</tr>
</tbody></table>
<p>以上标签属性不需要死记硬背，因为后面我们会慢慢使用它们，所以现在只需要有一个印象即可。</p>
<hr>
<h1 id="预准备"><a href="#预准备" class="headerlink" title="预准备"></a><span class="underline">预准备</span></h1><p><strong>我们在开始讲解之前，先在Navicat中导入数据库文件：myemployees，搭建好数据库。</strong></p>
<p><strong>然后再搭建好我们的mybatis环境：</strong></p>
<p><strong>步骤一：创建maven项目，pom.xml文件的代码如下:</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;

         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;

         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0

http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    

    &lt;groupId&gt;org.example&lt;/groupId&gt;

    &lt;artifactId&gt;MyBatis_02_Mapper映射文件详解&lt;/artifactId&gt;

    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;

    

        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;

        &lt;dependency&gt;

            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;

            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;

            &lt;version&gt;3.5.6&lt;/version&gt;

        &lt;/dependency&gt;

        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;

        &lt;dependency&gt;

            &lt;groupId&gt;mysql&lt;/groupId&gt;

            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;

            &lt;version&gt;8.0.16&lt;/version&gt;

        &lt;/dependency&gt;

        &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;

        &lt;dependency&gt;

            &lt;groupId&gt;log4j&lt;/groupId&gt;

            &lt;artifactId&gt;log4j&lt;/artifactId&gt;

            &lt;version&gt;1.2.17&lt;/version&gt;

        &lt;/dependency&gt;

        &lt;dependency&gt;

            &lt;groupId&gt;junit&lt;/groupId&gt;

            &lt;artifactId&gt;junit&lt;/artifactId&gt;

            &lt;version&gt;4.12&lt;/version&gt;

            &lt;scope&gt;test&lt;/scope&gt;

        &lt;/dependency&gt;

   &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<p><strong>步骤二：创建log4j.properties，配置log4j用于记录mybatis的日志，方便后面查看BUG、缓存等，十分方便。</strong></p>
<pre><code class="properties">log4j.rootLogger=DEBUG,Console

#Console

log4j.appender.Console=org.apache.log4j.ConsoleAppender

log4j.appender.console.Target=System.out

log4j.appender.Console.layout=org.apache.log4j.PatternLayout

log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n

log4j.logger.org.apache=ERROR

log4j.logger.org.mybatis=ERROR

log4j.logger.org.springframework=ERROR

#这个需要

log4j.logger.log4jdbc.debug=ERROR

log4j.logger.com.gk.mapper=ERROR

log4j.logger.jdbc.audit=ERROR

log4j.logger.jdbc.resultset=ERROR

#这个打印SQL语句非常重要

log4j.logger.jdbc.sqlonly=DEBUG

log4j.logger.jdbc.sqltiming=ERROR

log4j.logger.jdbc.connection=FATAL
</code></pre>
<p><strong>步骤三：创建db.properties文件，存放数据库信息</strong></p>
<pre><code class="properties">driver=com.mysql.cj.jdbc.Driver

url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT&amp;useUnicode=true&amp;characterEncoding=utf8

username=root

password=mysql0917
</code></pre>
<p><strong>步骤四：编写配置文件</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;

&lt;!DOCTYPE configuration

        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;

        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;

&lt;configuration&gt;

    

    &lt;!-- 引入外部db.properties --&gt;

    &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt;

    

    &lt;!-- settings用来控制mybatis运行时的行为，是mybatis中的重要配置 --&gt;

    &lt;settings&gt;

        &lt;!-- 设置MyBatis支持Log4j --&gt;

        &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;

    &lt;/settings&gt;

    

    &lt;!-- 配置指定包路径下，所有类的别名 --&gt;

    &lt;typeAliases&gt;

        &lt;package name=&quot;com.sys.bean&quot;/&gt;

    &lt;/typeAliases&gt;

    

    &lt;!-- 环境配置 --&gt;

    &lt;environments default=&quot;development&quot;&gt;

        &lt;!-- id：表示不同环境的名称 --&gt;

        &lt;environment id=&quot;development&quot;&gt;

            &lt;transactionManager type=&quot;JDBC&quot;/&gt;

            &lt;dataSource type=&quot;POOLED&quot;&gt;

                &lt;!-- 使用$&#123;&#125;来引入外部变量 --&gt;

                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;

                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;

                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;

                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;

            &lt;/dataSource&gt;

        &lt;/environment&gt;

    &lt;/environments&gt;

    

    &lt;!-- 指定sql所适用的数据库 --&gt;

    &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;

        &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt;

        &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&gt;

    &lt;/databaseIdProvider&gt;

    

    &lt;!-- 批量注册mapper映射文件，使用注解编写SQL语句 --&gt;

    &lt;mappers&gt;

    &lt;package name=&quot;com.sys.mapper&quot;/&gt;

    &lt;/mappers&gt;

&lt;/configuration&gt;
</code></pre>
<p><strong>步骤五：按照配置文件的</strong><code>&lt;typeAliases&gt;</code><strong>和</strong><code>&lt;mappers&gt;</code><strong>创建好对应的包</strong></p>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705182012704-16570249044113.png" alt="image-20220705182012704"></p>
<h1 id="一、SELECT之-关于参数传递的问题"><a href="#一、SELECT之-关于参数传递的问题" class="headerlink" title="一、SELECT之 关于参数传递的问题"></a><span class="underline">一、SELECT之 关于参数传递的问题</span></h1><p>在前面的例子当中，MyBatis会将 Mapper接口方法中的参数值 传递给 mapper映射文件中sql语句，然后会进行sql语句的拼接，获得一个完整的sql语句：</p>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705143659689-16570248922011.png" alt="image-20220705143659689"></p>
<h2 id="在参数传递的时候，我们分为以下几种情况讨论下："><a href="#在参数传递的时候，我们分为以下几种情况讨论下：" class="headerlink" title="在参数传递的时候，我们分为以下几种情况讨论下："></a>在参数传递的时候，我们分为以下几种情况讨论下：</h2><h2 id="1、当接口方法的参数有且仅有一个时"><a href="#1、当接口方法的参数有且仅有一个时" class="headerlink" title="1、当接口方法的参数有且仅有一个时"></a>1、当接口方法的参数有且仅有一个时</h2><ol>
<li><p><strong>若为基本数据类型、字符串，sql语句中参数：#{参数名} mapper接口方法：</strong></p>
<pre><code class="java">/**
 * 根据id查询员工的信息
 * @param id
 * @retuen 
 */

 Employee findEmpById( int id );
</code></pre>
</li>
</ol>
<p><strong>mapper映射文件：</strong></p>
<pre><code>&lt;select id=&quot;findEmpById&quot; parameterType=&quot;int&quot; resultType=&quot;Employee&quot;&gt;
    SELECT * FROM employees WHERE employee_id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705143622329-16570250270737.png" alt="image-20220705143622329"></p>
<p>&#x3D;&#x3D;<strong>在#{}中，填写形参的名字即可。</strong>&#x3D;&#x3D;</p>
<p><strong>测试代码：</strong></p>
<pre><code class="java">@Test
public void testFindEmpById()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    // 这里的实参101就会传递到sql语句中进行拼接 
    Employee emp = mapper.findEmpById(101); 
    System.out.println( emp ); 
    sqlSession.close();
&#125;
</code></pre>
<ol start="2">
<li><strong>若为引用数据类型，sql语句中参数：#{该类的属性名}</strong></li>
</ol>
<p>​		我们还可以将 <strong>需要拼接到sql语句中的数据</strong> 封装进我们的对象当中。这种方式也可以解决多个参数传递的问题，当然主流方式在				后面的第二种情况中。</p>
<p><strong>mapper接口方法：</strong></p>
<pre><code>/**
 *根据id查询指定的员工
 *
 *我们也可以将可以使用引用类型作为参数
 *该类型的对象中存放的就是：需要拼接到sql的数据
 *@param employee
 *@return
 */
Employee findEmpById2( Employee employee );
</code></pre>
<p><strong>mapper映射文件：</strong></p>
<pre><code>&lt;select id=&quot;findEmpById2&quot; resultType=&quot;Employee&quot;&gt;
    SELECT * FROM employees WHERE employee_id = #&#123;employee_id&#125;
&lt;/select&gt;
</code></pre>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705144207673-16570250447229.png" alt="image-20220705144207673"></p>
<p>&#x3D;&#x3D;在#{}中，填写指定类型对象中的属性名即可。&#x3D;&#x3D;</p>
<p><strong>测试代码：</strong></p>
<pre><code>@Test
public void testFindEmpById2()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    // 创建一个Employee对象
    Employee employee = new Employee();
    // 将需要拼接到sql语句中的数据存放到对象当中
    employee.setEmployee_id(101);
    // 将该对象作为实参传递
    Employee emp = mapper.indEmpById2( employee ); System.out.println( emp );
    sqlSession.close();
&#125;
</code></pre>
<h2 id="2、当接口方法的参数有多个时"><a href="#2、当接口方法的参数有多个时" class="headerlink" title="2、当接口方法的参数有多个时"></a>2、当接口方法的参数有多个时</h2><p>在这种情况下，就不能按照第一种情况的第(1)部分写了，当然 第(2)部分提到的：<strong>将 需要拼接到sql语句中的数据 封装进对象</strong>是可以解决这种情况的，但是这种方法适用面不广泛。现在主流的方式：使用 @Param注解。</p>
<p>现在，我们先来看看MyBatis是如何获取参数值的：</p>
<p>MyBatis在处理接口方法的多个参数的时候，会将这些参数封装到一个map中，此时map中的 key就是arg0、arg1、param1、param2这些值，但是很明显，这样的传值方式不是很友好，我 们也不知道arg0、arg1等key所对应的值是什么，很不方便。所以，我们可以采用 @Param注解来设置 map中的key值，这样就很方便了！！！</p>
<p>若不使用@Param注解，则会抛出如下异常：</p>
<p>&#x3D;&#x3D;Cause: org.apache.ibatis.binding.BindingException:Parameter &#39;fName&#39; not found. Available parameters are [arg1, arg0, param1, param2]&#x3D;&#x3D;</p>
<p>我们现在来看看这个注解怎么使用：</p>
<p><strong>mapper接口方法：</strong></p>
<pre><code>/**
 *根据姓、名查询员工的信息
 *@param fName：名
 *@param lName：姓
 *@return
 */
Employee findEmpByNames(@Param(&quot;fN&quot;) String fName, @Param(&quot;lN&quot;)String lName);
</code></pre>
<p><strong>mapper映射文件：</strong></p>
<pre><code>&lt;select id=&quot;findEmpByNames&quot; resultType=&quot;Employee&quot;&gt;
    SELECT * FROM employees WHERE first_name = #&#123;fN&#125; AND last_name = #&#123;lN&#125;;
&lt;/select&gt;
</code></pre>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705144431072-165702506166211.png" alt="image-20220705144431072"></p>
<p><strong>测试代码：</strong></p>
<pre><code>@Test
public void testFindEmpByNames()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); 
    Employee emp = mapper.findEmpByNames(&quot;Steven&quot;, &quot;K_ing&quot;); 
    System.out.println( emp );
    sqlSession.close();
&#125;
</code></pre>
<h2 id="3、使用map来传递参数"><a href="#3、使用map来传递参数" class="headerlink" title="3、使用map来传递参数"></a>3、使用map来传递参数</h2><p>​	既然MyBatis使用自带的map集合来存放参数值，那么我们也可以将参数存放在map集合中，此时依然是直接使用#{key}来获取具			体的参数值。</p>
<p>​	<strong>mapper接口方法：</strong></p>
<pre><code>/**
 *使用map来传递参数
 *@param map
 *@return
 */
Employee findEmpByMap(Map&lt;String, String&gt; map);
</code></pre>
<p><strong>mapper映射文件：</strong></p>
<pre><code class="xml">&lt;select id=&quot;findEmpByMap&quot; resultType=&quot;Employee&quot;&gt;
    SELECT * FROM employees WHERE first_name = #&#123;first_name&#125; AND last_name = #&#123;last_name&#125;;
&lt;/select&gt;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220705144606706.png" alt="image-20220705144606706"></p>
<p><strong>测试方法：</strong></p>
<pre><code>@Test
public void testFindEmpByMap()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); 
    HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); 
    map.put(&quot;first_name&quot;, &quot;Steven&quot;);
    map.put(&quot;last_name&quot;, &quot;K_ing&quot;);
    Employee emp = mapper.findEmpByMap(map); 
    System.out.println( emp ); 
    sqlSession.close();
&#125;
</code></pre>
<h1 id="二、SELECT之-获取参数拼接到SQL语句的问题"><a href="#二、SELECT之-获取参数拼接到SQL语句的问题" class="headerlink" title="二、SELECT之 获取参数拼接到SQL语句的问题"></a><span class="underline">二、SELECT之 获取参数拼接到SQL语句的问题</span></h1><p>​	当使用<code>#&#123;&#125;</code>来获取值的时候会发现打印的sql语句如下：</p>
<pre><code>select from emp where empno=? and ename=?
</code></pre>
<p>​	当使用<code>$&#123;&#125;</code>来获取值的时候会发现打印的sql语句如下：</p>
<pre><code>select from emp where empno=7369 and ename=&#39;SMITH&#39;
</code></pre>
<p>​	通过刚刚的案例大家已经发现了存在的问题了：</p>
<ol>
<li>若使用<code>#&#123;&#125;</code>方式进行取值：采用的是参数预编译的方式，参数的位置使用？进行替代，不会出现sql注入的问题。</li>
<li>若使用<code>$&#123;&#125;</code>方式进行取值：采用的是直接跟sql语句进行拼接的方式，此时会出现sql注入的问题。</li>
</ol>
<p>​	<strong>所以，我们现在都是采用 <code>#&#123;&#125;</code>，以防止sql注入。</strong></p>
<h1 id="三、SELECT之-处理集合类型的返回结果"><a href="#三、SELECT之-处理集合类型的返回结果" class="headerlink" title="三、SELECT之 处理集合类型的返回结果"></a><span class="underline">三、SELECT之 处理集合类型的返回结果</span></h1><h2 id="1、List集合的处理"><a href="#1、List集合的处理" class="headerlink" title="1、List集合的处理"></a>1、List集合的处理</h2><p>当返回值的结果是List集合时， resultType 返回值的类型写的是：<strong>集合中每一个元素的具体数据类型</strong>。</p>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705145030745-165702541132028.png" alt="image-20220705145030745"></p>
<p><strong>mapper接口方法：</strong></p>
<pre><code>/**
 *获取所有的emp
 *@return：集合对象
 */
List&lt;Employee&gt; findAllEmp();
</code></pre>
<p><strong>mapper映射文件：</strong></p>
<pre><code>&lt;!--
    当返回值的结果是集合的时候，返回值的类型依然写的是集合中具体的类型（map除外）
--&gt;
&lt;select id=&quot;findAllEmp&quot; resultType=&quot;Employee&quot;&gt; 
    SELECT * FROM employees
&lt;/select&gt;
</code></pre>
<p><strong>测试方法：</strong></p>
<pre><code>@Test
public void testFindAllEmp()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    List&lt;Employee&gt; allEmp = mapper.findAllEmp();
    for (Employee emp: allEmp) &#123;
        System.out.println( emp );
    &#125;
    sqlSession.close();
&#125;
</code></pre>
<h2 id="2、Map集合的处理"><a href="#2、Map集合的处理" class="headerlink" title="2、Map集合的处理"></a>2、Map集合的处理</h2><p>   由于map集合比较特殊，它含有key和value，所以我们分两种情况说明：</p>
<ol>
<li>使用map存放一条数据时：</li>
</ol>
<p>​	在查询的时候，若mysql只返回一条数据，此时返回值的类型也可以设置为map，当mybatis查询完成之后会把列名作为key，列的值作为value，转换到map中。</p>
<p><strong>mapper接口方法：</strong></p>
<pre><code>/**
 *返回的是map对象
 *@param id
 *@return
 */
Map&lt;String, Object&gt; findEmpByIdReturnMap(int id);
</code></pre>
<p><strong>mapper映射文件：</strong></p>
<pre><code>&lt;!--
    使用map存放一条数据
    在查询的时候，若mysql只返回一条数据，此时返回值的类型也可以设置为map，当mybatis查询完成之后会把列名作为key，列的值	  作为value，转换到map中
--&gt;
&lt;select id=&quot;findEmpByIdReturnMap&quot; resultType=&quot;map&quot;&gt; 
    SELECT * FROM employees WHERE employee_id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p><strong>测试方法：</strong></p>
<pre><code>@Test
public void testFindEmpByIdReturnMap()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    Map&lt;String, Object&gt; map = mapper.findEmpByIdReturnMap(101); 
    for ( Map.Entry&lt;String, Object&gt; entry : map.entrySet() ) &#123;
        System.out.println( entry.getKey() +&quot;---&gt;&quot;+ entry.getValue() );
    &#125;
    sqlSession.close();
&#125;
</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705145332855-165702544762330.png" alt="image-20220705145332855"></p>
<ol start="2">
<li>使用map存放多条数据时：</li>
</ol>
<p>​		当使用map存放多条数据时，返回值的类型一定要写map中value的类型，同时在mapper接口的方法上要添加**@MapKey**的注				解，来设置key是什么。</p>
<p><strong>mapper接口方法：</strong></p>
<pre><code>/**
 *使用map存放多条数据
 *@return
 *
 *注解：@MapKey(&quot;employee_id&quot;)  ===》设置map集合的key为数据表中的employee_id字段
 */ @MapKey(&quot;employee_id&quot;)
Map&lt;Integer,Employee&gt; findAllEmpReturnMap();
</code></pre>
<p><strong>mapper映射文件：</strong></p>
<pre><code>&lt;!--
    使用map存放多条数据注意：
    当使用map存放多条数据时，返回值的类型一定要写map中value的类型
    同时在mapper接口的方法上要添加@MapKey的注解，来设置key是什么结果
--&gt;
&lt;select id=&quot;findAllEmpReturnMap&quot; resultType=&quot;Employee&quot;&gt; 
    SELECT * FROM employees
&lt;/select&gt;
</code></pre>
<p><strong>测试方法：</strong></p>
<pre><code>@Test
public void testFindAllEmpReturnMap()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); 
    Map&lt;Integer, Employee&gt; emps = mapper.findAllEmpReturnMap(); 
    for (Map.Entry&lt;Integer, Employee&gt; entry: emps.entrySet() ) &#123;
        System.out.println( entry.getKey() +&quot;---&gt;&quot;+ entry.getValue() );
    &#125;
    sqlSession.close();
&#125;
</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705145519320-165702513940713.png" alt="image-20220705145519320"></p>
<h1 id="四、级联查询"><a href="#四、级联查询" class="headerlink" title="四、级联查询"></a><span class="underline">四、级联查询</span></h1><h2 id="1、自定义结果集映射"><a href="#1、自定义结果集映射" class="headerlink" title="1、自定义结果集映射"></a>1、自定义结果集映射</h2><p><strong>引入：</strong>我们前面在创建一个实体类的时候，我们都是将类中的属性 和 数据表的字段写的一模一样，方便 MyBatis可以直接 属性名\字段名 进行结果集映射。但是在现实场景中，总会有实体类的属性名会和字段名不一样的情况，此时直接进行结果集映射是会出现异常的。所以针对这种情况，我们需要使用<code>&lt;resultMap&gt;</code>来自定义结果集映射。</p>
<p><strong>编写实体类Department</strong></p>
<pre><code class="java">package com.sys.bean;


/**
 *@program: MyBatis_02_Mapper映射文件详解
 *@description: 部门实体类
 *@author: DW
 * @create: 2021-09-26 22:07
 */
public class Department &#123;

    private Integer dept_id; 
    private String dept_name; 
    private Integer manager_id; 
    private Integer location_id;

    public Department() &#123;
    &#125;


    public Department(Integer dept_id,String dept_name,Integer manager_id,Integer location_id) &#123;
    this.dept_id = dept_id; 
    this.dept_name = dept_name; 
    this.manager_id = manager_id; 
    this.location_id = location_id;
    &#125;


    public Integer getDept_id() &#123; 
        return dept_id;
    &#125;


    public void setDept_id(Integer dept_id) &#123; 
        this.dept_id = dept_id;
    &#125;


    public String getDept_name() &#123; 
        return dept_name;
    &#125;


    public void setDept_name(String dept_name) &#123; 
        this.dept_name = dept_name;
    &#125;


    public Integer getManager_id() &#123;
        return manager_id;
    &#125;


    public void setManager_id(Integer manager_id) &#123; 
        this.manager_id = manager_id;
    &#125;


    public Integer getLocation_id() &#123; 
        return location_id;
    &#125;


    public void setLocation_id(Integer location_id) &#123;
        this.location_id = location_id;
    &#125;



    @Override
    public String toString() &#123; 
        return &quot;Department&#123;&quot; +
               &quot;dept_id=&quot; + dept_id +
               &quot;, dept_name=&#39;&quot; + dept_name + &#39;\&#39;&#39; + 
               &quot;, manager_id=&quot; + manager_id +
               &quot;, location_id=&quot; + location_id + 
               &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p><strong>编写mapper接口：创建一个名为DeptMapper的接口</strong></p>
<pre><code>package com.sys.mapper;

import com.sys.bean.Department;

import java.util.List;

/**
 *@program: MyBatis_02_Mapper映射文件详解
 *@description: 部门表的mapper接口
 *@author: DW
 * @create: 2021-09-26 22:09
 */
public interface DeptMapper &#123;

    /**
     *根据部门id查询指定的部门信息
     *@param id
     *@return
     */
    Department findDeptById( int id );
&#125;
</code></pre>
<p><strong>编写Mapper映射文件：</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
 		PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
  		&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.sys.mapper.DeptMapper&quot;&gt;
    &lt;!--
        使用&lt;resultMap&gt;来自定义结果集映射，用于告诉MaBatis数据表中的字段要和哪个属性进行映射属性：
        id：resultMap的名字，方便在其他标签中引用
        type：和resultType，告诉MyBatis需要将结果集中的数据按照 自定义的结果集映射规则 封装成什么类型的对象
    --&gt;
    &lt;resultMap id=&quot;deptMapper&quot; type=&quot;department&quot;&gt;
        &lt;!--
            &lt;id&gt;标签：设置数据表中的主键 和 实体类的属性 的映射属性：
            column：主键名 property：属性名
        --&gt;
        &lt;id column=&quot;department_id&quot; property=&quot;dept_id&quot;&gt;&lt;/id&gt;
        &lt;!--
            &lt;result&gt;标签：设置数据表中的字段 和 实体类的属性 的映射属性：
            column：字段名 property：属性名
        --&gt;
        &lt;result column=&quot;department_name&quot; property=&quot;dept_name&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;manager_id&quot; property=&quot;manager_id&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;location_id&quot; property=&quot;location_id&quot;&gt;&lt;/result&gt;
    &lt;/resultMap&gt;

    &lt;!--
        根据部门id查询指定的部门信息
        Department findDeptById( int id );
        注意：这里不再是使用resultType属性而是使用resultMap属性来引用上面的自定义结果集映射
    --&gt;
    &lt;select id=&quot;findDeptById&quot; resultMap=&quot;deptMapper&quot;&gt;
        SELECT * FROM departments WHERE department_id = #&#123;id&#125;
    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<p><strong>编写测试方法进行测试：</strong></p>
<pre><code>import com.sys.bean.Department; 
import com.sys.bean.Employee; 
import com.sys.mapper.DeptMapper; 
import com.sys.mapper.EmpMapper;
import org.apache.ibatis.io.Resources; 
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory; 
import org.apache.ibatis.session.SqlSessionFactoryBuilder; 
import org.junit.After;
import org.junit.Before; 
import org.junit.Test;

import java.io.IOException; 
import java.io.InputStream; 
import java.util.HashMap; 
import java.util.List; 
import java.util.Map;

/**
 *@program: MyBatis_02_Mapper映射文件详解
 *@description: 测试EmpMapper
 *@author: DW
 * @create: 2021-09-13 16:04
 */
public class TestDeptMapper &#123;


    private SqlSession sqlSession;

    @Before
    public void getSqlSession()&#123;
        // 根据全局配置文件创建出SqlSessionFactory
        //  SqlSessionFactory:负责创建SqlSession对象的工厂
        // SqlSession:表示跟数据库建议的一次会话 
        String resource = &quot;mybatis-config.xml&quot;; 
        InputStream inputStream = null;
        try &#123;
            inputStream = Resources.getResourceAsStream(resource);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

        // 获取数据库的会话
        sqlSession = sqlSessionFactory.openSession();
&#125;


    @Test
    public void testFindDeptById()&#123;
        DeptMapper mapper = sqlSession.getMapper(DeptMapper.class); 
        Department dept = mapper.findDeptById(10); 
        System.out.println( dept );
    &#125;


    @After
    public void release()&#123; 
        sqlSession.close();
    &#125;


&#125;
</code></pre>
<h2 id="2、级联查询"><a href="#2、级联查询" class="headerlink" title="2、级联查询"></a>2、级联查询</h2><p>在现实场景中对数据库的查询不可能仅限于单表查询，有时候会涉及到多表查询。多表查询：也称级联查询，表示本次查询操作会涉及多个数据表的数据。</p>
<h3 id="2-1、一对一"><a href="#2-1、一对一" class="headerlink" title="2.1、一对一"></a>2.1、一对一</h3><p>当涉及到多表查询的时候，就需要考虑到表中数据之间的关系。</p>
<p><strong>需求：</strong>根据员工id查询指定员工的信息，并查询该员工所在的部门信息。</p>
<p><strong>分析：</strong>那么这里设计到两张表，由于一个员工只能属于某一个部门，所以这里员工和部门之间的关系就是”一对一”的关系。</p>
<p><strong>SQL语句：</strong>以125进行举例分析</p>
<pre><code class="xml">SELECT *
FROM employees e
LEFT JOIN departments d
ON e.department_id = d.department_id 
WHERE e.employee_id = 125
</code></pre>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705173921680-165702548072232.png" alt="image-20220705173921680"></p>
<p>从以上的运行结果发现整个结果集中的数据分为两部分：employees和departments 。如何来处理这个结果集呢？分表使用两个对象？还是使用一个employee对象呢？</p>
<p><strong>实体类设计：</strong></p>
<p>既然两者是一对一的关系，我们可以在Employee中添加一个Department属性：</p>
<pre><code>/**
 * 员工所在的部门
 */
private Department dept;
</code></pre>
<p>并为该属性添加set和get方法：</p>
<pre><code>public Department getDept() &#123; 
    return dept;
&#125;

public void setDept(Department dept) &#123; 
    this.dept = dept;
&#125;
</code></pre>
<p>再次重写toString()方法：</p>
<pre><code>@Override
public String toString() &#123; 
    return &quot;Employee&#123;&quot; +
        &quot;employee_id=&quot; + employee_id +
        &quot;, first_name=&#39;&quot; + first_name + &#39;\&#39;&#39; + 
        &quot;, last_name=&#39;&quot; + last_name + &#39;\&#39;&#39; + 
        &quot;, email=&#39;&quot; + email + &#39;\&#39;&#39; +
        &quot;, phone_number=&#39;&quot; + phone_number + &#39;\&#39;&#39; + 
        &quot;, job_id=&#39;&quot; + job_id + &#39;\&#39;&#39; +
        &quot;, salary=&quot; + salary +
        &quot;, commission_pct=&quot; + commission_pct + 
        &quot;, manager_id=&quot; + manager_id +
        &quot;, department_id=&quot; + department_id + 
        &quot;, hiredate=&quot; + hiredate +
        &quot;, dept=&quot; + dept + &#39;&#125;&#39;;
&#125;
</code></pre>
<p><strong>修改EmpMapper接口：</strong></p>
<pre><code>/**
 *根据员工id查询指定员工的信息，并查询该员工所在的部门信息。
 *@param id
 *@return
 */
Employee findEmpAndDept( int id );
</code></pre>
<p><strong>修改EmpMapper映射文件：</strong></p>
<pre><code>&lt;!--
    由于这里的结果集包含两部分的数据，所以需要使用resultMap设置字段名和属性名之间的映射，将结果集中的数据封装进
    现在的employee对象当中。
--&gt;
&lt;resultMap id=&quot;empJoinDept&quot; type=&quot;employee&quot;&gt;
    &lt;id column=&quot;employee_id&quot; property=&quot;employee_id&quot;&gt;&lt;/id&gt;
    &lt;result column=&quot;first_name&quot; property=&quot;first_name&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;last_name&quot; property=&quot;last_name&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;email&quot; property=&quot;email&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;phone_number&quot; property=&quot;phone_number&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;job_id&quot; property=&quot;job_id&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;salary&quot; property=&quot;salary&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;commission_pct&quot; property=&quot;commission_pct&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;manager_id&quot; property=&quot;manager_id&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;department_id&quot; property=&quot;department_id&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;hiredate&quot; property=&quot;hiredate&quot;&gt;&lt;/result&gt;
    &lt;!--
        association：用于一对一的关系，设置实体类属性的自定义结果集映射 
        property：实体类属性的名字
        javaType：指定实体类属性所属的实体类
    --&gt;
    &lt;association property=&quot;dept&quot; javaType=&quot;department&quot;&gt;
        &lt;id column=&quot;department_id&quot; property=&quot;dept_id&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;department_name&quot; property=&quot;dept_name&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;manager_id&quot; property=&quot;manager_id&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;location_id&quot; property=&quot;location_id&quot;&gt;&lt;/result&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;


&lt;!--
    根据员工id查询指定员工的信息，并查询该员工所在的部门信息。
    Employee findEmpAndDept( int id );
--&gt;
&lt;select id=&quot;findEmpAndDept&quot; resultMap=&quot;empJoinDept&quot; &gt; 
    SELECT *
    FROM employees e
    LEFT JOIN departments d
    ON e.department_id = d.department_id 
    WHERE e.employee_id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<p><strong>编写测试类方法：</strong></p>
<pre><code>@Test
public void testFindEmpAndDept()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); 
    Employee employee = mapper.findEmpAndDept(114); 
    System.out.println( employee );
&#125;
</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705174628111-165702549304034.png" alt="image-20220705174628111"></p>
<h3 id="2-2-、一对多"><a href="#2-2-、一对多" class="headerlink" title="2.2 、一对多"></a>2.2 、一对多</h3><p><strong>需求：</strong>根据部门id查询指定部门的信息，并查询该部门下所有的员工信息。</p>
<p><strong>分析：</strong>那么这里设计到两张表，由于一个部门下会有多个员工，所以这里部门和员工之间的关系就是”一对多”的关系。</p>
<p><strong>SQL语句：</strong>以30进行举例分析</p>
<pre><code>SELECT *
FROM departments d
LEFT JOIN employees e
ON d.department_id = e.department_id 
WHERE d.department_id=30
</code></pre>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705174856719-165702550024736.png" alt="image-20220705174856719"></p>
<p>参考上一小节的内容，我们需要在Department实体类中添加一个和Employee相关的属性，根据上图一个Department对象会对应多		个Employee对象，所有这里需要使用集合来存放这些Employee对象。</p>
<p><strong>实体类设计：</strong>在Department实体类中添加集合</p>
<pre><code> /**
  * 集合属性，用于一对多时，存放多个Employee对象   
  */
 private List&lt;Employee&gt; employeeList;
</code></pre>
<p><strong>修改DeptMapper接口：</strong></p>
<pre><code>/**
 *根据部门id查询指定部门的信息，并查询该部门下所有的员工信息。
 *@return
 */
List&lt;Department&gt; findAllDeptJoinEmpById(int id);
</code></pre>
<p><strong>编写DeptMapper映射文件：</strong></p>
<pre><code>&lt;resultMap id=&quot;deptJoinEmp&quot; type=&quot;department&quot;&gt;
    &lt;id column=&quot;department_id&quot; property=&quot;dept_id&quot;&gt;&lt;/id&gt;
    &lt;result column=&quot;department_name&quot; property=&quot;dept_name&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;manager_id&quot; property=&quot;manager_id&quot;&gt;&lt;/result&gt;
    &lt;result column=&quot;location_id&quot; property=&quot;location_id&quot;&gt;&lt;/result&gt;
    &lt;!--
        &lt;collection&gt;标签：用于设置集合属性的自定义结果集映射 
        property：集合属性名
        ofType：指定集合属性的泛型
    --&gt;
    &lt;collection property=&quot;employeeList&quot; ofType=&quot;employee&quot;&gt;
        &lt;id column=&quot;employee_id&quot; property=&quot;employee_id&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;first_name&quot; property=&quot;first_name&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;last_name&quot; property=&quot;last_name&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;email&quot; property=&quot;email&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;phone_number&quot; property=&quot;phone_number&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;job_id&quot; property=&quot;job_id&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;salary&quot; property=&quot;salary&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;commission_pct&quot; property=&quot;commission_pct&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;manager_id&quot; property=&quot;manager_id&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;department_id&quot; property=&quot;department_id&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;hiredate&quot; property=&quot;hiredate&quot;&gt;&lt;/result&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre>
<p><strong>编写测试方法：</strong></p>
<pre><code>@Test
public void testFindEmpAndDept()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); 
    Employee employee = mapper.findEmpAndDept(114); 
    System.out.println( employee );
&#125;
</code></pre>
<p><strong>运行结果：</strong></p>
<p><img src="/assets/%E7%AC%AC2%E7%AB%A0%20%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20220705175345436-165702550939538.png" alt="image-20220705175345436"></p>
<h1 id="五、动态sql"><a href="#五、动态sql" class="headerlink" title="五、动态sql"></a><span class="underline">五、动态sql</span></h1><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><pre><code>需求1：根据id查询员工信息。

需求2：根据first_name查询员工信息。

需求3：根据last_name查询员工信息。

需求4：根据email查询员工信息。

等等。
</code></pre>
<p>若我们根据以上需求去写代码，其实是没问题的，只不过我们需要写很多的mapper接口方法以mapper映射文件。而且整个SQL语句		中，SELECT语句是没变的，唯独是WHERE子句一直在变化，所以我们能否将上述一系列的SQL语句整合在一起呢？让WHERE子句部		门根据不同的情况而动态变化呢？</p>
<p>此时，那就使用使用动态SQL了。</p>
<h2 id="1、多条件查询"><a href="#1、多条件查询" class="headerlink" title="1、多条件查询"></a>1、多条件查询</h2><h3 id="1-1、if标签"><a href="#1-1、if标签" class="headerlink" title="1.1、if标签"></a>1.1、if标签</h3><p>我们来实现下引入部分的需求。</p>
<p><strong>修改EmpMapper接口：</strong></p>
<pre><code>/**
 *动态sql：多条件查询
 *@param  employee：由于条件的个数不确定，所以将多个条件封装进employee对象当中
 *@return
 */
List&lt;Employee&gt; findEmpsByConditions(Employee employee);
</code></pre>
<p><strong>修改EmpMapper映射文件：</strong></p>
<pre><code>&lt;!--
    动态sql：多条件查询，根据employees表当中的多个字段进行查询
    List&lt;Employee&gt; findEmpsByConditions(Employee employee);
--&gt;
&lt;select id=&quot;findEmpsByConditions&quot; resultType=&quot;employee&quot;&gt; 
    SELECT * FROM employees WHERE 1=1
    &lt;!--
        if标签
        test：写形参的判断条件，当判断条件为true时，MyBatis会将AND子句拼接进SELECT语句中
        注意：形参需要根据接口方法的形参、#&#123;参数&#125;去写
    --&gt;
    &lt;if test=&quot;employee_id != 0&quot;&gt;
        AND employee_id = #&#123;employee_id&#125;
    &lt;/if&gt;
    &lt;if test=&quot;first_name != null and first_name != &#39;&#39;&quot;&gt; 
        AND first_name = #&#123;first_name&#125;
    &lt;/if&gt;
    &lt;if test=&quot;last_name != null and last_name != &#39;&#39;&quot;&gt; 
        AND last_name = #&#123;last_name&#125;
    &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<p><strong>编写测试方法：</strong></p>
<pre><code>@Test
public void testFindEmpsByConditions()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    
    // 创建employee对象，通过set方法将参数封装进该对象当中
    Employee employee = new Employee();
    
    // employee.setEmployee_id(132);
    employee.setFirst_name(&quot;TJ&quot;);
    
    // employee.setLast_name(&quot;Olson&quot;);
    List&lt;Employee&gt; emps = mapper.findEmpsByConditions(employee);
    
    // 遍历集合
    for ( Employee emp : emps) &#123;
        System.out.println(emp);
    &#125;
&#125;
</code></pre>
<p><code>&lt;if&gt;</code> <strong>标签说明：</strong></p>
<p>当if标签中的test属性为true的时候，MyBatis就会将该if标签中的sql拼接进select语句，所以使用该标签</p>
<p><strong>可以拼接任意个条件</strong>。</p>
<p>if标签相当是Java当中的”与运算”，也类似于if单分支结构，但是不支持if...else...结构的功能。</p>
<h3 id="1-2、choose标签"><a href="#1-2、choose标签" class="headerlink" title="1.2、choose标签"></a>1.2、choose标签</h3><p>和 if标签 对应的还有一个choose标签。我们先来看看该标签怎么使用。</p>
<p><strong>修改EmpMapper接口：</strong></p>
<pre><code>/**
 * 动态sql2
 * @param employee：将多个条件封装进employee对象当中
 * @return
 */
List&lt;Employee&gt; findEmpsByConditions2(Employee employee);
</code></pre>
<p><strong>修改EmpMapper映射文件：</strong></p>
<pre><code>&lt;!--
    动态sql2
    List&lt;Employee&gt; findEmpsByConditions2(Employee employee);
--&gt;
&lt;select id=&quot;findEmpsByConditions2&quot; resultType=&quot;employee&quot;&gt;
    SELECT * FROM employees WHERE 1=1
    &lt;choose&gt;
        &lt;when test=&quot;employee_id != 0&quot;&gt;
            AND employee_id = #&#123;employee_id&#125;
        &lt;/when&gt;
        &lt;when test=&quot;first_name != null and first_name != &#39;&#39;&quot;&gt;
            AND first_name = #&#123;first_name&#125;
        &lt;/when&gt;
        &lt;when test=&quot;last_name != null and last_name != &#39;&#39;&quot;&gt;
            AND last_name = #&#123;last_name&#125;
        &lt;/when&gt;
    &lt;/choose&gt;
&lt;/select&gt;
</code></pre>
<p><strong>编写测试方法：</strong></p>
<p>​	</p>
<pre><code>@Test
public void testFindEmpsByConditions2()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);

    // 创建employee对象，通过set方法将参数封装进该对象当中 
    Employee employee = new Employee(); 
    employee.setEmployee_id(132); 
    employee.setFirst_name(&quot;TJ&quot;); 
    employee.setLast_name(&quot;Olson&quot;);

    List&lt;Employee&gt; emps = mapper.findEmpsByConditions2(employee);

    // 遍历集合
    for ( Employee emp : emps) &#123; 
        System.out.println(emp);
    &#125;
&#125;
</code></pre>
<p><code>&lt;choose&gt;</code> <strong>标签说明：</strong></p>
<p>在choose当中，<strong>when标签语句是从上往下依次执行的</strong>，</p>
<p>（1）若when标签中的test属性为false时，会继续往下执行；</p>
<p>（2）当遇到了when标签中的test属性为true时，则整个choose就结束，MyBatis会将该when标签中的</p>
<p>​		  sql拼接进select语句。</p>
<p>（3）当所有的when标签都为false的时候，就会执行otherwise标签，若没有otherwise标签，则直接结束整个choose，此时无sql语				 句拼接。</p>
<p>所以 choose标签能拼接0个或者1个条件。</p>
<p>choose相当于是Java当中的”或运算”，类似switch结构，choose相当于是switch，when相当于case， otherwise相当于default。</p>
<p><strong>注意：</strong>当choose结构在某个when标签中结束时， 后面when标签是没有执行的。</p>
<h2 id="2、in子句的动态参数问题"><a href="#2、in子句的动态参数问题" class="headerlink" title="2、in子句的动态参数问题"></a>2、in子句的动态参数问题</h2><p><strong>需求：</strong>根据job_id去查询员工信息。</p>
<p><strong>分析：</strong>在现实场景中，job_id是由前端页面发送到后端的，用户在输入job_id时，可能输入了1个、2</p>
<p>个、3个...N个等等。所以我们的SQL语句当中的参数也是动态变化的。</p>
<p><strong>修改EmpMapper接口：</strong></p>
<pre><code>/**
 * 动态sql：in字句中的参数动态变化
 * 需求：根据job_id去查询员工信息（job_id可能有1个、2个、3个...N个）
 * @param job_ids
 * @return
 */
List&lt;Employee&gt; findEmpsByJobIds(List&lt;String&gt; job_ids);
</code></pre>
<p><strong>修改EmpMapper映射文件：</strong></p>
<pre><code>&lt;!--
    List&lt;Employee&gt; findEmpsByJobIds(List&lt;String&gt; job_ids);
--&gt;
&lt;select id=&quot;findEmpsByJobIds&quot; resultType=&quot;employee&quot;&gt;
    SELECT * FROM employees WHERE job_id IN
    &lt;!--
        foreach标签：用于处理接口方法的参数为集合的情况，主要解决in子句中动态参数的问题
        属性：
        item：设置集合中元素的别名
        index：设置集合中元素的索引类型，List集合则为：index
        collection：表示集合的类型，List集合则为：list
        open：in子句的开始标记：(
        separator：表示in子句的分隔符：,
        close：in子句的结束标记：)
        
        注意：sql语句的参数 #&#123;item的属性值&#125;
    --&gt;
    &lt;foreach item=&quot;jid&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot;
    separator=&quot;,&quot; close=&quot;)&quot;&gt;
        #&#123;jid&#125;
    &lt;/foreach&gt;
&lt;/select&gt;
</code></pre>
<p><strong>编写测试方法：</strong></p>
<pre><code>@Test
public void testFindEmpsByJobIds()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    
    List&lt;String&gt; job_ids = new ArrayList&lt;String&gt;();
    job_ids.add(&quot;ST_CLERK&quot;);
    job_ids.add(&quot;SA_MAN&quot;);
    
    List&lt;Employee&gt; emps = mapper.findEmpsByJobIds(job_ids);
    
    // 遍历集合
    for ( Employee emp : emps) &#123;
        System.out.println(emp);
    &#125;
&#125;
</code></pre>
<p>foreach标签常见使用场景是对集合进行遍历，尤其是在构建 IN 条件语句的时候。</p>
<p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符！</p>
<p><strong>提示</strong>：你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p>
<h2 id="3、SQL片段"><a href="#3、SQL片段" class="headerlink" title="3、SQL片段"></a>3、SQL片段</h2><p>这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在	    不同的 include 元素中定义不同的参数值。</p>
<p>比如：我们的EmpMapper映射文件中出现了许多的<code>&quot;SELECT * FROM employees&quot;</code> 那我们是否可以将它们提取出来呢？</p>
<pre><code>&lt;!--
    SQL片段
--&gt;
&lt;sql id=&quot;select*Emp&quot;&gt;
    SELECT * FROM employees
&lt;/sql&gt;

&lt;!--
    动态sql：多条件查询，根据employees表当中的多个字段进行查询
    List&lt;Employee&gt; findEmpsByConditions(Employee employee);
--&gt;
&lt;select id=&quot;findEmpsByConditions&quot; resultType=&quot;employee&quot;&gt;
    &lt;include refid=&quot;select*Emp&quot;&gt;&lt;/include&gt; WHERE 1=1
    &lt;!--
        if标签
        test：写形参的判断条件，当判断条件为true时，MyBatis会将AND子句拼接进SELECT语句中
        注意：形参需要根据接口方法的形参、#&#123;参数&#125;去写
    --&gt;
    &lt;if test=&quot;employee_id != 0&quot;&gt;
        AND employee_id = #&#123;employee_id&#125;
    &lt;/if&gt;
    &lt;if test=&quot;first_name != null and first_name != &#39;&#39;&quot;&gt;
        AND first_name = #&#123;first_name&#125;
    &lt;/if&gt;
    &lt;if test=&quot;last_name != null and last_name != &#39;&#39;&quot;&gt;
        AND last_name = #&#123;last_name&#125;
    &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<h1 id="六、其他操作"><a href="#六、其他操作" class="headerlink" title="六、其他操作"></a><span class="underline">六、其他操作</span></h1><h2 id="1、insert操作"><a href="#1、insert操作" class="headerlink" title="1、insert操作"></a>1、insert操作</h2><p><strong>需求：</strong>在employees表中添加一行数据<strong>在EmpMapper接口中编写方法：</strong></p>
<pre><code>/**
 * 添加数据
 * @param employee
 * @return
 */
Integer addEmp(Employee employee);
</code></pre>
<p><strong>修改EmpMapper映射文件：</strong></p>
<pre><code>&lt;insert id=&quot;addEmp&quot;&gt;
    INSERT INTO employees (first_name,last_name,email)
    VALUES (#&#123;first_name&#125;,#&#123;last_name&#125;,#&#123;email&#125;)
&lt;/insert&gt;
</code></pre>
<p><strong>编写测试方法：</strong></p>
<pre><code>@Test
public void testAddEmp()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    
    Employee employee = new Employee();
    employee.setFirst_name(&quot;Wei&quot;);
    employee.setLast_name(&quot;Wu&quot;);
    employee.setEmail(&quot;1323789218@qq.com&quot;);
    
    Integer row = mapper.addEmp(employee);
    // 提交操作，否则数据不会保存到数据库当中
    sqlSession.commit();
    System.out.println(&quot;影响的行数为：&quot;+row);
&#125;
</code></pre>
<h2 id="2、update操作"><a href="#2、update操作" class="headerlink" title="2、update操作"></a>2、update操作</h2><p><strong>需求：</strong>修改刚刚添加的数据。</p>
<p><strong>在EmpMapper接口中编写方法：</strong></p>
<pre><code>/**
 * 修改指定员工的数据
 * @param last_name
 * @return
 */
Integer updateEmp(@Param(&quot;l_name&quot;) String last_name, @Param(&quot;id&quot;) int id);
</code></pre>
<p><strong>修改EmpMapper映射文件：</strong></p>
<pre><code>&lt;update id=&quot;updateEmp&quot;&gt;
    UPDATE employees SET
    last_name = #&#123;l_name&#125;
    WHERE employee_id = #&#123;id&#125;
&lt;/update&gt;
</code></pre>
<p><strong>编写测试方法：</strong></p>
<pre><code>@Test
public void testUpdateEmp()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    Integer row = mapper.updateEmp(&quot;HaSaGei&quot;, 218);
    
    // 提交操作，否则数据不会保存到数据库当中
    sqlSession.commit();
    System.out.println(&quot;影响的行数为：&quot;+row);
&#125;
</code></pre>
<h2 id="3、delete操作"><a href="#3、delete操作" class="headerlink" title="3、delete操作"></a>3、delete操作</h2><p><strong>需求：</strong>删除刚刚添加的数据。</p>
<p><strong>在EmpMapper接口中编写方法：</strong></p>
<pre><code>/**
 * 删除指定的员工信息
 * @param id
 * @return
 */
Integer deleteEmp(int id);
</code></pre>
<p><strong>修改EmpMapper映射文件：</strong></p>
<pre><code>&lt;delete id=&quot;deleteEmp&quot;&gt;
    DELETE FROM employees WHERE employee_id = #&#123;id&#125;
&lt;/delete&gt;
</code></pre>
<p><strong>编写测试方法：</strong></p>
<pre><code>@Test
public void testDeleteEmp()&#123;
    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
    Integer row = mapper.deleteEmp(218);
    
    // 提交操作，否则数据不会保存到数据库当中
    sqlSession.commit();
    System.out.println(&quot;影响的行数为：&quot;+row);
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #00bcd4">
                SSM
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/MyBatis/" style="color: #00bcd4">
                MyBatis
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/第2章 映射文件详解/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/18/Spring_狂神说/">
        <h2 class="post-title">Spring_狂神说</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/SSM/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                SSM
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h3 id="1、Spring"><a href="#1、Spring" class="headerlink" title="1、Spring"></a>1、Spring</h3><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><ul>
<li><p>Spring : 春天 —&gt;给软件行业带来了春天</p>
</li>
<li><p>2002年，首次推出了Spring框架的雏形：interface21框架！</p>
</li>
<li><p>2004年3月24日，Spring框架即以interface21框架为基础，经过重新设计，发布了1.0正式版。</p>
</li>
<li><p>Rod Johnson，Spring Framework创始人，著名作者。很难想象Rod Johnson的学历 , 他是悉尼大学的博士，然而他的专业不是计算机，而是音乐学。</p>
</li>
<li><p>Spring理念 : 使现有技术更加实用 . 本身就是一个大杂烩 , 整合现有的框架技术</p>
</li>
</ul>
<p>官网 : <a target="_blank" rel="noopener" href="http://spring.io/">http://spring.io/</a></p>
<p>官方下载地址 : <a target="_blank" rel="noopener" href="https://repo.spring.io/libs-release-local/org/springframework/spring/">https://repo.spring.io/libs-release-local/org/springframework/spring/</a></p>
<p>GitHub : <a target="_blank" rel="noopener" href="https://github.com/spring-projects">https://github.com/spring-projects</a></p>
<ul>
<li>SSH：Struct2 + Spring + Hibernate</li>
<li>SSM: SpringMVC + Spring + Mybatis</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.springframework/spring-webmvc">Spring Web MVC</a> <strong>»</strong> <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.springframework/spring-webmvc/5.3.18">5.3.18.RELEASE</a></p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.3.18&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.3.18&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="1-2、优点"><a href="#1-2、优点" class="headerlink" title="1.2、优点"></a>1.2、优点</h3><ul>
<li>Spring是一个开源的免费的框架（容器）！</li>
<li>Spring是一个轻量级的框架 , 非侵入式的 .</li>
<li>控制反转（IOC） , 面向切面 编程（AOP）</li>
<li>支持事务的处理，对框架整合的支持！</li>
</ul>
<p><strong>&#x3D;&#x3D;总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架！&#x3D;&#x3D;</strong></p>
<h3 id="1-3、组成"><a href="#1-3、组成" class="headerlink" title="1.3、组成"></a>1.3、组成</h3><p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/640.png" alt="图片"></p>
<h3 id="1-4、扩展"><a href="#1-4、扩展" class="headerlink" title="1.4、扩展"></a>1.4、扩展</h3><p>在Spring的官网有这个介绍：现代化的Java开发！说白了就是基于Spring的开发！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220714104441236.png" alt="image-20220714104441236"></p>
<ul>
<li>Spring Boot<ul>
<li>一个快速开发的脚手架</li>
<li>基于SpringBoot可以快速的开发单个微服务</li>
<li>约定大于配置</li>
</ul>
</li>
<li>Spring Cloud<ul>
<li>SpringCloud是基于SpringBoot实现的</li>
</ul>
</li>
</ul>
<p>因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring以及SpringMVC！<strong>承上启下的作用！</strong></p>
<p><strong>弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，人称：“配置地狱”</strong></p>
<h2 id="2、IOC理论推导"><a href="#2、IOC理论推导" class="headerlink" title="2、IOC理论推导"></a>2、IOC理论推导</h2><ol>
<li><p>UserDao 接口</p>
</li>
<li><p>UserDaoImpl 实现类</p>
</li>
<li><p>UserService 业务接口</p>
</li>
<li><p>UserServiceImpl 业务实现类</p>
</li>
</ol>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修		改一次的成本代价十分昂贵！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201109112133683.png" alt="20201109112133683"></p>
<p>我们使用一个Set接口实现，已经发生了革命性的变化！</p>
<pre><code class="java">    private UserDao userDao;

    //利用set进行动态实现值的注入！
    public void setUserDao(UserDao userDao) &#123;
        this.userDao = userDao;
    &#125;
</code></pre>
<ul>
<li>之前，程序是主动创建对象！控制权在程序员手上！</li>
<li>使用了set注入后，程序不再具有主动性，而是变成了被动的接收对象！</li>
</ul>
<p>这种思想，从本质上解决了问题，我们程序猿不用再去管理对象的创建了。系统的耦合性大大降低~，可以更加专注的在业务的实现		上！这是IOC的原型！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201109112157443.png" alt="20201109112157443"></p>
<h3 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h3><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。		没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制		反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/640-16578062531225.png" alt="640"></p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
<h2 id="3、HelloSpring"><a href="#3、HelloSpring" class="headerlink" title="3、HelloSpring"></a>3、HelloSpring</h2><h3 id="1-新建一个maven项目，编写实体类"><a href="#1-新建一个maven项目，编写实体类" class="headerlink" title="1.新建一个maven项目，编写实体类"></a>1.新建一个maven项目，编写实体类</h3><pre><code class="java">public class Hello &#123;
    private String str;

    public String getStr() &#123;
        return str;
    &#125;

    public void setStr(String str) &#123;
        this.str = str;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Hello&#123;&quot; +
                &quot;str=&#39;&quot; + str + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<h3 id="2-编写xml配置文件"><a href="#2-编写xml配置文件" class="headerlink" title="2.编写xml配置文件"></a>2.编写xml配置文件</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;


    &lt;!--使用Spring来创建对象，在Spring这些都称为Bean
    类型 变量名 = new 类型();
    Hello hello = new Hello();

    id = 变量名
    class = new的对象
    property 相当于给对象中的属性设置一个值！
        --&gt;
    &lt;bean id=&quot;hello&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h3><pre><code class="java">public class MyTest &#123;
    public static void main(String[] args) &#123;
        //获取Spring的上下文对象！
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);

        //我们的对象现在都在Spring中的管理了，我们需要使用，直接去里面取出来就可以！
        Hello hello = (Hello) context.getBean(&quot;hello&quot;);
        System.out.println(hello.toString());
    &#125;
&#125;
</code></pre>
<h3 id="思考问题？"><a href="#思考问题？" class="headerlink" title="思考问题？"></a><strong>思考问题？</strong></h3><ul>
<li>Hello对象是谁创建的？<br>Hello对象是由Spring创建的。</li>
<li>Hello对象的属性是怎么设置的？<br>Hello对象的属性是由Spring容器设置的。</li>
</ul>
<p>这个过程就叫控制反转：</p>
<p><strong>控制</strong>：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的。</p>
<p><strong>反转</strong>：程序本身不创建对象，而变成被动的接收对象。</p>
<p><strong>依赖注入</strong>：就是利用set方法来进行注入的。</p>
<p>IOC是一种编程思想，由主动的编程变成被动的接收。</p>
<p>可以通过new ClassPathXmlApplicationContext去浏览一下底层源码。</p>
<p><strong>OK，到了现在，我们彻底不用在程序中去改动了，要实现不同的操作，只需要在xml配置文件中进行修改，所谓的IOC，一句话搞定：对象由Spring来创建，管理，装配！</strong></p>
<h2 id="4、IOC创建对象的方式"><a href="#4、IOC创建对象的方式" class="headerlink" title="4、IOC创建对象的方式"></a>4、IOC创建对象的方式</h2><ol>
<li><p>使用无参构造创建对象，默认！</p>
</li>
<li><p>假设我们要使用有参构造创建对象。</p>
<ol>
<li>下标赋值</li>
</ol>
<pre><code class="xml">&lt;!--第一种方式：下标赋值    --&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;狂神说Java&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="2">
<li>类型</li>
</ol>
<pre><code class="xml">&lt;!--第二种方式：通过类型的创建，不建议使用    --&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;lifa&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="3">
<li>参数名</li>
</ol>
<pre><code class="xml">&lt;!--第三种方式：直接通过参数名来设置    --&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;李发&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！</p>
</li>
</ol>
<h2 id="5、Spring配置"><a href="#5、Spring配置" class="headerlink" title="5、Spring配置"></a>5、Spring配置</h2><h3 id="5-1-别名"><a href="#5-1-别名" class="headerlink" title="5.1 别名"></a>5.1 别名</h3><pre><code class="xml">    &lt;!--别名，如果添加了别名，我们也可以使用别名获取到这个对象--&gt;
    &lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;/&gt;
</code></pre>
<h3 id="5-2-Bean配置"><a href="#5-2-Bean配置" class="headerlink" title="5.2 Bean配置"></a>5.2 Bean配置</h3><pre><code class="xml">    &lt;!--
    id：bean的唯一标识符，也就是相当于我们学的对象名
    class：bean对象所对应的全限定名：包名+类名
    name：也是别名，而且name可以同时取多个别名
        --&gt;
    &lt;bean id=&quot;userT&quot; class=&quot;com.kuang.pojo.UserT&quot; name=&quot;user2 u2,u3;u4&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;黑心白莲&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<h3 id="5-3-import"><a href="#5-3-import" class="headerlink" title="5.3 import"></a>5.3 import</h3><p>这个import。一般用于团队开发使用，它可以将多个配置文件，导入合并为一个。<br>假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！</p>
<ul>
<li><p>张三</p>
</li>
<li><p>李四</p>
</li>
<li><p>王五</p>
</li>
<li><p>applicationContext.xml</p>
<pre><code class="xml">&lt;import resource=&quot;bean.xml&quot;/&gt;
&lt;import resource=&quot;bean2.xml&quot;/&gt;
&lt;import resource=&quot;bean3.xml&quot;/&gt;
</code></pre>
</li>
</ul>
<p>使用的时候，直接使用总的配置就可以了。</p>
<h2 id="6、依赖注入-DI"><a href="#6、依赖注入-DI" class="headerlink" title="6、依赖注入(DI)"></a>6、依赖注入(DI)</h2><h3 id="6-1-构造器注入"><a href="#6-1-构造器注入" class="headerlink" title="6.1 构造器注入"></a>6.1 构造器注入</h3><p>前面已经介绍过，参考<strong>4、IOC创建对象的方式</strong></p>
<h3 id="6-2-Set方式注入【重点】"><a href="#6-2-Set方式注入【重点】" class="headerlink" title="6.2 Set方式注入【重点】"></a>6.2 Set方式注入【重点】</h3><ul>
<li>依赖注入：Set注入<ul>
<li>依赖：bean对象的创建依赖于容器！</li>
<li>注入：bean对象中的所有属性，由容器来注入！</li>
</ul>
</li>
</ul>
<p>【环境搭建】</p>
<ol>
<li>复杂类型</li>
</ol>
<pre><code class="java">public class Address &#123;
    private String address;

    public String getAddress() &#123;
        return address;
    &#125;

    public void setAddress(String address) &#123;
        this.address = address;
    &#125;
&#125;
</code></pre>
<ol>
<li>真实测试对象</li>
</ol>
<pre><code class="java">public class Student &#123;

    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbies;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private String wife;
    private Properties info;
&#125;
</code></pre>
<ol>
<li>beans.xml</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
        &lt;!--第一种：普通值注入，value        --&gt;
        &lt;property name=&quot;name&quot; value=&quot;黑心白莲&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol>
<li>测试类</li>
</ol>
<pre><code class="java">public class MyTest &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);

        Student student = (Student) context.getBean(&quot;student&quot;);
        System.out.println(student.getName());
    &#125;
&#125;
</code></pre>
<ol>
<li>完善注入信息</li>
</ol>
<pre><code class="xml">    &lt;bean id=&quot;address&quot; class=&quot;com.kuang.pojo.Address&quot;&gt;
        &lt;property name=&quot;address&quot; value=&quot;西安&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt;
        &lt;!--第一种：普通值注入，value        --&gt;
        &lt;property name=&quot;name&quot; value=&quot;黑心白莲&quot;/&gt;

        &lt;!--第二种：Bean注入，ref        --&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;

        &lt;!--第三种：数组注入，        --&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;红楼梦&lt;/value&gt;
                &lt;value&gt;西游记&lt;/value&gt;
                &lt;value&gt;水浒传&lt;/value&gt;
                &lt;value&gt;三国演义&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;

        &lt;!--List        --&gt;
        &lt;property name=&quot;hobbies&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;打篮球&lt;/value&gt;
                &lt;value&gt;看电影&lt;/value&gt;
                &lt;value&gt;敲代码&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;

        &lt;!--Map        --&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;123456789987456321&quot;/&gt;
                &lt;entry key=&quot;银行卡&quot; value=&quot;359419496419481649&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;

        &lt;!--Set        --&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;LOL&lt;/value&gt;
                &lt;value&gt;COC&lt;/value&gt;
                &lt;value&gt;BOB&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;

        &lt;!--NULL        --&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;

        &lt;!--Properties        --&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;driver&quot;&gt;20191029&lt;/prop&gt;
                &lt;prop key=&quot;url&quot;&gt;102.0913.524.4585&lt;/prop&gt;
                &lt;prop key=&quot;user&quot;&gt;黑心白莲&lt;/prop&gt;
                &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;

    &lt;/bean&gt;
折叠 
</code></pre>
<h3 id="6-3-拓展方式注入"><a href="#6-3-拓展方式注入" class="headerlink" title="6.3 拓展方式注入"></a>6.3 拓展方式注入</h3><p>我们可以使用p命名空间和c命名空间进行注入</p>
<p>官方解释：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201110193916911.png" alt="20201110193916911"></p>
<p>使用：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--p命名空间注入，可以直接注入属性的值：property--&gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.kuang.pojo.User&quot; p:name=&quot;黑心白莲&quot; p:age=&quot;20&quot;/&gt;

    &lt;!--c命名空间注入，通过构造器注入：constructor-args--&gt;
    &lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;22&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p>测试：</p>
<pre><code class="java">    @Test
    public void test2()&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;);

        User user = context.getBean(&quot;user&quot;,User.class);
        System.out.println(user);

        User user2 = context.getBean(&quot;user2&quot;,User.class);
        System.out.println(user2);
    &#125;
</code></pre>
<p>注意点：p命名空间和c命名空间不能直接使用，需要导入xml约束</p>
<pre><code class="xml">       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
</code></pre>
<h3 id="6-4-bean的作用域"><a href="#6-4-bean的作用域" class="headerlink" title="6.4 bean的作用域"></a>6.4 bean的作用域</h3><p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201111101635200.png" alt="20201111101635200"></p>
<ol>
<li>单例模式（Spring默认机制）</li>
</ol>
<pre><code class="xml">&lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;22&quot; scope=&quot;singleton&quot;/&gt;
</code></pre>
<ol start="2">
<li>原型模式：每次从容器中get的时候，都会产生一个新对象！</li>
</ol>
<pre><code class="xml">&lt;bean id=&quot;user2&quot; class=&quot;com.kuang.pojo.User&quot; c:name=&quot;狂神&quot; c:age=&quot;22&quot; scope=&quot;prototype&quot;/&gt;
</code></pre>
<ol start="3">
<li>其余的request、session、application、这些只能在web开发中用到！</li>
</ol>
<h2 id="7、Bean的自动装配"><a href="#7、Bean的自动装配" class="headerlink" title="7、Bean的自动装配"></a>7、Bean的自动装配</h2><ul>
<li>自动装配是Spring满足bean依赖的一种方式</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性</li>
</ul>
<p>在Spring中有三种装配的方式：</p>
<ol>
<li>在xml中显式的配置；</li>
<li>在java中显式配置；</li>
<li>隐式的自动装配bean【重要】</li>
</ol>
<h3 id="7-1-测试"><a href="#7-1-测试" class="headerlink" title="7.1 测试"></a>7.1 测试</h3><p>环境搭建：创建项目，一个人有两个宠物！</p>
<pre><code class="xml">    &lt;bean id=&quot;cat&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
    &lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;

    &lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;小白莲&quot;/&gt;
        &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;
        &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<h3 id="7-2-ByName自动装配"><a href="#7-2-ByName自动装配" class="headerlink" title="7.2 ByName自动装配"></a>7.2 ByName自动装配</h3><pre><code class="xml">        &lt;!--
        byName：会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！
            --&gt;
        &lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byName&quot;&gt;
            &lt;property name=&quot;name&quot; value=&quot;小白莲&quot;/&gt;
        &lt;/bean&gt;
</code></pre>
<h3 id="7-3-ByType自动装配"><a href="#7-3-ByType自动装配" class="headerlink" title="7.3 ByType自动装配"></a>7.3 ByType自动装配</h3><pre><code class="xml">        &lt;!--
        byType：会自动在容器上下文中查找，和自己对象属性类型相同的bean！
            --&gt;
        &lt;bean id=&quot;people&quot; class=&quot;com.kuang.pojo.People&quot; autowire=&quot;byType&quot;&gt;
            &lt;property name=&quot;name&quot; value=&quot;小白莲&quot;/&gt;
        &lt;/bean&gt;
</code></pre>
<p>小结：</p>
<ul>
<li>ByName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！</li>
<li>ByType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！</li>
</ul>
<h3 id="7-4-使用注解实现自动装配"><a href="#7-4-使用注解实现自动装配" class="headerlink" title="7.4 使用注解实现自动装配"></a>7.4 使用注解实现自动装配</h3><p>jdk1.5支持的注解，Spring2.5就支持注解了！</p>
<p>要使用注解须知：</p>
<ol>
<li><p>导入约束：context约束</p>
</li>
<li><p>&#x3D;&#x3D;配置注解的支持 ：<a href="context:annotation-config/">context:annotation-config/</a>&#x3D;&#x3D;</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        
        &lt;!--开启注解的支持    --&gt;
        &lt;context:annotation-config/&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ol>
<p><strong>@Autowired</strong></p>
<p>直接在属性上使用即可！也可以在set方法上使用！</p>
<p>使用Autowried我们就可以不用编写set方法了，前提是你这个自动配置的属性在IOC(Spring)容器中存在，且符合名字ByName！</p>
<p><strong>科普：</strong></p>
<pre><code>@Nullable 字段标记了了这个注解，说明这个字段可以为null;
</code></pre>
<pre><code class="java">public @interface Autowired &#123;
    boolean required() default true;
&#125;
</code></pre>
<p>测试代码</p>
<pre><code class="java">public class People &#123;
    //如果显式定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空
    @Autowired(required = false)
    private Cat cat;
    @Autowired
    private Dog dog;
    private String name;
&#125;
</code></pre>
<p>&#x3D;&#x3D;如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value &#x3D; “xxx”)去配置@Autowired的使用，指定一个唯一的bean对象注入！【重点！】&#x3D;&#x3D;</p>
<pre><code class="java">public class People &#123;
    @Autowired
    @Qualifier(value = &quot;cat111&quot;)
    private Cat cat;
    @Autowired
    @Qualifier(value = &quot;dog222&quot;)
    private Dog dog;
    private String name;
&#125;
</code></pre>
<p><strong>@Resource</strong></p>
<pre><code class="java">public class People &#123;

    @Resource
    private Cat cat;

    @Resource
    private Dog dog;
&#125;
</code></pre>
<p>小结：</p>
<p>@Resource和@Autowired的区别：</p>
<ul>
<li>都是用来自动装配的，都可以放在属性字段上</li>
<li>@Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】</li>
<li>@Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】</li>
<li>执行顺序不同：@Autowired通过byType的方式实现。</li>
</ul>
<h2 id="8、使用注解开发"><a href="#8、使用注解开发" class="headerlink" title="8、使用注解开发"></a>8、使用注解开发</h2><p>在Spring4之后，要使用注解开发，必须要保证aop的包导入了</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220716221045108.png" alt="image-20220716221045108"></p>
<p>使用注解需要导入约束，配置注解的支持！</p>
<pre><code class="xml">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
           xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
           xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                https://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/context
                https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
            
            &lt;!--开启注解的支持    --&gt;
            &lt;context:annotation-config/&gt;
    &lt;/beans&gt;
</code></pre>
<h3 id="1-Bean的实现"><a href="#1-Bean的实现" class="headerlink" title="1. Bean的实现"></a><strong>1. Bean的实现</strong></h3><p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p>
<ol>
<li>配置扫描那些包下的注解</li>
</ol>
<pre><code class="xml">&lt;!--指定注解扫描包--&gt;
&lt;context:component-scan base-package=&quot;com.kuang.pojo&quot;/&gt;
</code></pre>
<ol start="2">
<li>在指定包下编写类，增加注释</li>
</ol>
<pre><code class="java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User &#123;
   public String name = &quot;秦疆&quot;;
&#125;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="java">@Test
public void test()&#123;
   ApplicationContext applicationContext =
       new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   User user = (User) applicationContext.getBean(&quot;user&quot;);
   System.out.println(user.name);
&#125;
</code></pre>
<p>&#x3D;&#x3D;使用@Component时：【重点】&#x3D;&#x3D;</p>
<ol>
<li>&#x3D;&#x3D;User user &#x3D; (User) context.getBean(“user”);只能这样写&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;User user &#x3D; context.getBean(“user”,User.class);这样写是无法查出的&#x3D;&#x3D;</li>
</ol>
<h3 id="2-属性注入"><a href="#2-属性注入" class="headerlink" title="2. 属性注入"></a>2. 属性注入</h3><p>使用注解注入属性</p>
<ol>
<li><p>可以不用提供set方法，直接在直接名上添加@value(“值”)</p>
<pre><code class="java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User &#123;
    
   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt;
   @Value(&quot;秦疆&quot;)
   public String name;
&#125;
</code></pre>
</li>
<li><p>如果提供了set方法，在set方法上添加@value(“值”)</p>
<pre><code class="java">@Component(&quot;user&quot;)
public class User &#123;

   public String name;
   // 相当于 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt;
   @Value(&quot;秦疆&quot;)
   public void setName(String name) &#123;
       this.name = name;
  &#125;
&#125;
</code></pre>
</li>
</ol>
<h3 id="3-衍生注解"><a href="#3-衍生注解" class="headerlink" title="3. 衍生注解"></a>3. 衍生注解</h3><p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p>
<p><strong>@Component三个衍生注解</strong></p>
<p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<ul>
<li>@Controller： web层	controller</li>
<li>@Service：service层     service</li>
<li>@Repository：dao层    dao</li>
</ul>
<p>写上这些注释，就相当于将这个类交给Spring管理装配了！</p>
<h3 id="4-自动装配注解"><a href="#4-自动装配注解" class="headerlink" title="4. 自动装配注解"></a>4. 自动装配注解</h3><p>在Bean的自动装配已经讲过了，可以回顾！</p>
<ul>
<li>@Autowired：自动装配通过类型，名字。如果Autowired不能唯一自动装配上属性，则需要通过@Qualifier(value &#x3D; “xxx”)去配置。</li>
<li>@Nullable 字段标记了了这个注解，说明这个字段可以为null;</li>
<li>@Resource：自动装配通过名字，类型。</li>
</ul>
<h3 id="5-作用域"><a href="#5-作用域" class="headerlink" title="5. 作用域"></a>5. 作用域</h3><p>@scope</p>
<ul>
<li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li>
<li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li>
</ul>
<pre><code class="java">@Component
@Scope(&quot;singleton&quot;)
public class User &#123;

    //相当于  &lt;property name=&quot;name&quot; value=&quot;白莲&quot;/&gt;
    @Value(&quot;白莲&quot;)
    public String name;
&#125;
</code></pre>
<h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a><strong>6. 小结</strong></h3><p><strong>xml与注解：</strong></p>
<ul>
<li>xml更加万能，适用于任何场合！维护简单方便</li>
<li>注解不是自己类使用不了，维护相队复杂！</li>
</ul>
<p><strong>xml与注解最佳实践：</strong></p>
<ul>
<li>xml用来管理bean；</li>
<li>注解只负责完成属性的注入；</li>
<li>我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持</li>
</ul>
<pre><code class="xml">    &lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;
    &lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt;
    &lt;!--开启注解的支持    --&gt;
    &lt;context:annotation-config/&gt;
</code></pre>
<p>作用：</p>
<ul>
<li>进行注解驱动注册，从而使注解生效</li>
<li>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</li>
<li>如果不扫描包，就需要手动配置bean</li>
<li>如果不加注解驱动，则注入的值为null！</li>
</ul>
<h2 id="9、使用Java的方式配置Spring"><a href="#9、使用Java的方式配置Spring" class="headerlink" title="9、使用Java的方式配置Spring"></a>9、使用Java的方式配置Spring</h2><p>我们现在要完全不适用spring的xml配置了，全权交给Java来做！</p>
<p>JavaConfig 是Spring的一个子项目，在Spring4 之后，他成为了一个核心功能！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201111151604718.png" alt="20201111151604718"></p>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><pre><code class="java">//这里这个注解的意思，就是说明这个类被Spring接管了，注册到了容器其中
@Component
public class User &#123;


    private String name;

    public String getName() &#123;
        return name;
    &#125;
    @Value(&quot;zh&quot;)    //属性注入值
    public void setName(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code class="java">package com.ccrt6.config;

import com.ccrt6.pojo.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

//这个也会被Spring容器托管，注册到容器中，因为他本来就是一个@Component
//@Configuration  代表这是一个配置类，就和我们之前看的beans.xml
@Configuration
@ComponentScan(&quot;com.ccrt6.pojo&quot;)
@Import(Ccrt6Config2.class)
public class Ccrt6Config &#123;


    //注册一个bean ，就相当于我们之前写的一个bean标签
    //这个方法中的名字，就相当于bean标签中的id属性
    //这个方法中的返回值，就相当于bean标签中的class属性
    @Bean
    public User user()&#123;
        return new User();  //就是返回要注入的bena的对象
    &#125;

&#125;
</code></pre>
<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><pre><code class="java">public class MyTest &#123;
    public static void main(String[] args) &#123;


        //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig 上下文来获取容器，通过配置类的class对象加载！
        ApplicationContext context = new AnnotationConfigApplicationContext(Ccrt6Config.class);

        User getUser = (User) context.getBean(&quot;user&quot;);

        System.out.println(getUser.toString());

    &#125;
&#125;
</code></pre>
<p>这种纯Java的配置方式，在SpringBoot中随处可见！</p>
<h2 id="10、代理模式"><a href="#10、代理模式" class="headerlink" title="10、代理模式"></a>10、代理模式</h2><p>为什么要学习代理模式？因为这就是SpringAOP的底层！【SpringAOP和SpringMVC】</p>
<p>代理模式的分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201112093129742.png" alt="20201112093129742"></p>
<h3 id="10-1-静态代理"><a href="#10-1-静态代理" class="headerlink" title="10.1 静态代理"></a>10.1 静态代理</h3><p>角色分析：</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色，代理真实角色后，我们一般会做一些附属操作</li>
<li>客户：访问代理对象的人！</li>
</ul>
<p>代码步骤：</p>
<ol>
<li>接口</li>
</ol>
<pre><code class="java">//租房
public interface Rent &#123;
    public void rent();
&#125;
</code></pre>
<ol>
<li>真实角色</li>
</ol>
<pre><code class="java">//房东
public class Host implements Rent&#123;
    public void rent() &#123;
        System.out.println(&quot;房东出租房子！&quot;);
    &#125;
&#125;
</code></pre>
<ol>
<li>代理角色</li>
</ol>
<pre><code class="java">public class Proxy implements Rent&#123;
    private Host host;

    public Proxy() &#123;
    &#125;

    public Proxy(Host host) &#123;
        this.host = host;
    &#125;

    public void rent() &#123;
        host.rent();
        seeHouse();
        sign();
        fee();
    &#125;

    //看房
    public void seeHouse()&#123;
        System.out.println(&quot;中介带着看房子！&quot;);
    &#125;

    //签合同
    public void sign()&#123;
        System.out.println(&quot;和中介签署租赁合同！&quot;);
    &#125;

    //收费用
    public void fee()&#123;
        System.out.println(&quot;中介收取费用！&quot;);
    &#125;
&#125;
</code></pre>
<ol>
<li>客户端访问代理角色</li>
</ol>
<pre><code class="java">public class Client &#123;
    public static void main(String[] args) &#123;
        //房东要出租房子
        Host host = new Host();
//        host.rent();

        //代理，中介帮房东出租房子，并且代理角色一般会有一些附属操作！
        Proxy proxy = new Proxy(host);

        //不用面对房东，直接找中介租房即可！
        proxy.rent();
    &#125;
&#125;
</code></pre>
<p>代理模式的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共角色就交给代理角色！实现了业务的分工！</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低~</li>
</ul>
<h3 id="10-2-加深理解"><a href="#10-2-加深理解" class="headerlink" title="10.2 加深理解"></a>10.2 加深理解</h3><p>代码步骤：</p>
<ol>
<li><p>接口</p>
<pre><code class="java">public interface UserService &#123;
    public void add();
    public void delete();
    public void update();
    public void query();
&#125;
</code></pre>
</li>
<li><p>真实角色</p>
<pre><code class="java">//真实角色
public class UserServiceImpl implements UserService&#123;
    public void add() &#123;
        System.out.println(&quot;增加了一个用户！&quot;);
    &#125;

    public void delete() &#123;
        System.out.println(&quot;删除了一个用户！&quot;);
    &#125;

    public void update() &#123;
        System.out.println(&quot;修改了一个用户！&quot;);
    &#125;

    public void query() &#123;
        System.out.println(&quot;查询了一个用户！&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>代理角色</p>
<pre><code class="java">public class UserServiceProxy implements UserService&#123;
    private UserServiceImpl userService;

    public void setUserService(UserServiceImpl userService) &#123;
        this.userService = userService;
    &#125;

    public void add() &#123;
        log(&quot;add&quot;);
        userService.add();
    &#125;

    public void delete() &#123;
        log(&quot;delete&quot;);
        userService.delete();
    &#125;

    public void update() &#123;
        log(&quot;update&quot;);
        userService.update();
    &#125;

    public void query() &#123;
        log(&quot;query&quot;);
        userService.query();
    &#125;

    public void log(String msg)&#123;
        System.out.println(&quot;[Debug] 使用了一个&quot;+msg+&quot;方法&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>客户端访问代理角色</p>
<pre><code class="java">public class Client &#123;
    public static void main(String[] args) &#123;
        UserServiceImpl userService = new UserServiceImpl();

        UserServiceProxy proxy = new UserServiceProxy();
        proxy.setUserService(userService);

        proxy.delete();
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p>聊聊AOP</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201112101554344.png" alt="20201112101554344"></p>
<h3 id="10-3-动态代理"><a href="#10-3-动态代理" class="headerlink" title="10.3 动态代理"></a>10.3 动态代理</h3><ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的！</li>
<li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理<ul>
<li>基于接口 — JDK动态代理【我们在这里使用】</li>
<li>基于类：cglib</li>
<li>java字节码实现：javassist</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy：代理；InvocationHandler：调用处理程序。</p>
<p>代码步骤：</p>
<ol>
<li><p>接口</p>
<pre><code class="java">public interface Rent &#123;
    public void rent();
&#125;
</code></pre>
</li>
<li><p>真实角色</p>
<pre><code class="java">public class Host implements Rent&#123;
    public void rent() &#123;
        System.out.println(&quot;房东要出租房子！&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>ProxyInvocationHandler类</p>
<pre><code class="java">//我们会用这个类，自动生成代理类！
public class ProxyInvocationHandler implements InvocationHandler &#123;
    //被代理的接口
    private Rent rent;

    public void setRent(Rent rent) &#123;
        this.rent = rent;
    &#125;

    //生成得到代理类
    public Object getProxy()&#123;
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),
                rent.getClass().getInterfaces(),this);
    &#125;

    //处理代理实例，并返回结果
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        //动态代理的本质，就是使用反射机制实现！
        Object result = method.invoke(rent, args);
        seeHose();
        fee();
        return result;
    &#125;

    public void seeHose()&#123;
        System.out.println(&quot;中介带着看房子！&quot;);
    &#125;

    public void fee()&#123;
        System.out.println(&quot;中介收取费用！&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">public class Client &#123;
    public static void main(String[] args) &#123;
        //真实角色
        Host host = new Host();

        //代理角色：现在没有
        ProxyInvocationHandler pih = new ProxyInvocationHandler();

        //通过调用程序处理角色来处理我们要调用的接口对象！
        pih.setRent(host);
        Rent proxy = (Rent) pih.getProxy(); //这里的proxy就是动态生成的，我们并没有写
        proxy.rent();

    &#125;
&#125;
</code></pre>
</li>
</ol>
<p>在此，我们可以提炼出ProxyInvocationHandler作为工具类</p>
<pre><code class="java">//用这个类自动生成代理类！
public class ProxyInvocationHandler implements InvocationHandler &#123;

    //被代理的接口
    private Object target;

    public void setTarget(Object target) &#123;
        this.target = target;
    &#125;

    //生成得到代理类
    public Object getProxy()&#123;
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),
                target.getClass().getInterfaces(),this);
    &#125;

    //处理代理实例，并返回结果
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        log(method.getName());
        Object result = method.invoke(target, args);
        return result;
    &#125;

    public void log(String msg)&#123;
        System.out.println(&quot;[Debug] 使用了一个&quot;+msg+&quot;方法&quot;);
    &#125;
&#125;
</code></pre>
<p>动态代理的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共角色就交给代理角色！实现了业务的分工！</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
<li>一个动态代理类代理的是一个接口，一般就是对应的一类业务</li>
<li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可！</li>
</ul>
<h2 id="11、AOP"><a href="#11、AOP" class="headerlink" title="11、AOP"></a>11、AOP</h2><h3 id="11-1-什么是AOP"><a href="#11-1-什么是AOP" class="headerlink" title="11.1 什么是AOP"></a>11.1 什么是AOP</h3><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201112130947442.png" alt="20201112130947442"></p>
<h3 id="11-2-AOP在Spring中的作用"><a href="#11-2-AOP在Spring中的作用" class="headerlink" title="11.2 AOP在Spring中的作用"></a>11.2 AOP在Spring中的作用</h3><p>提供声明式事务；允许用户自定义切面</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等…</li>
<li>切面（ASPECT）：横切关注点被模块化的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知执行的“地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201112131307360.png" alt="20201112131307360"></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201120104439637.png" alt="20201120104439637"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201120104454887.png" alt="20201120104454887"></p>
<p>即AOP在不改变原有代码的情况下，去增加新的功能。</p>
<h3 id="11-3-使用Spring实现AOP"><a href="#11-3-使用Spring实现AOP" class="headerlink" title="11.3 使用Spring实现AOP"></a>11.3 使用Spring实现AOP</h3><p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>方式一：</strong> 使用Spring的API接口【主要是SpringAPI接口实现】</p>
<ol>
<li>在service包下，定义UserService业务接口和UserServiceImpl实现类</li>
</ol>
<pre><code class="java">public interface UserService &#123;
    public void add();
    public void delete();
    public void update();
    public void select();
&#125;
public class UserServiceImpl implements UserService &#123;
    public void add() &#123;
        System.out.println(&quot;增加了一个用户！&quot;);
    &#125;

    public void delete() &#123;
        System.out.println(&quot;删除了一个用户！&quot;);
    &#125;

    public void update() &#123;
        System.out.println(&quot;更新了一个用户！&quot;);
    &#125;

    public void select() &#123;
        System.out.println(&quot;查询了一个用户！&quot;);
    &#125;
&#125;
</code></pre>
<ol>
<li>在log包下，定义我们的增强类，一个Log前置增强和一个AfterLog后置增强类</li>
</ol>
<pre><code class="java">public class Log implements MethodBeforeAdvice &#123;

    //method: 要执行的目标对象的方法
    //args：参数
    //target：目标对象
    public void before(Method method, Object[] agrs, Object target) throws Throwable &#123;
        System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;);
    &#125;
&#125;
public class AfterLog implements AfterReturningAdvice &#123;

    //returnValue： 返回值
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;
        System.out.println(&quot;执行了&quot;+method.getName()+&quot;方法，返回结果为：&quot;+returnValue);
    &#125;
&#125;
</code></pre>
<ol>
<li>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束，配置applicationContext.xml文件</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!--注册bean--&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.kuang.service.UserServiceImpl&quot;/&gt;
    &lt;bean id=&quot;log&quot; class=&quot;com.kuang.log.Log&quot;/&gt;
    &lt;bean id=&quot;afterLog&quot; class=&quot;com.kuang.log.AfterLog&quot;/&gt;

    &lt;!--方式一：使用原生Spring API接口--&gt;
    &lt;!--配置aop:需要导入aop的约束--&gt;
    &lt;aop:config&gt;
        &lt;!--切入点：expression：表达式，execution(要执行的位置！* * * * *)--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;

        &lt;!--执行环绕增加！--&gt;
        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<ol>
<li>测试</li>
</ol>
<pre><code class="java">public class MyTest &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

        //动态代理代理的是接口：注意点
        UserService userService = (UserService) context.getBean(&quot;userService&quot;);

        userService.add();
//        userService.select();
    &#125;
&#125;
</code></pre>
<p><strong>方式二：</strong> 自定义类来实现AOP【主要是切面定义】</p>
<ol>
<li>在diy包下定义自己的DiyPointCut切入类</li>
</ol>
<pre><code class="java">public class DiyPointCut &#123;
    public void before()&#123;
        System.out.println(&quot;======方法执行前======&quot;);
    &#125;

    public void after()&#123;
        System.out.println(&quot;======方法执行后======&quot;);
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>去spring中配置文件</li>
</ol>
<pre><code class="xml">    &lt;!--方式二：自定义类--&gt;
    &lt;bean id=&quot;diy&quot; class=&quot;com.kuang.diy.DiyPointCut&quot;/&gt;

    &lt;aop:config&gt;
        &lt;!--自定义切面，ref 要引用的类--&gt;
        &lt;aop:aspect ref=&quot;diy&quot;&gt;
            &lt;!--切入点--&gt;
            &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
            &lt;!--通知--&gt;
            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;
            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
</code></pre>
<ol start="3">
<li><p>测试</p>
<pre><code class="java">public class MyTest &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //动态代理代理的是接口 : 注意点
        UserService userService = (UserService) context.getBean(&quot;userServiceImpl&quot;);

        userService.add();
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p><strong>方式三：</strong> 使用注解实现！</p>
<ol>
<li>在diy包下定义注解实现的AnnotationPointCut增强类</li>
</ol>
<pre><code class="java">//声明式事务！
@Aspect //标注这个类是一个切面
public class AnnotationPointCut &#123;

    @Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
    public void before()&#123;
        System.out.println(&quot;====方法执行前====&quot;);
    &#125;

    @After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
    public void after()&#123;
        System.out.println(&quot;====方法执行后====&quot;);
    &#125;

    //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点；
    @Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)
    public void around(ProceedingJoinPoint jp) throws Throwable&#123;
        System.out.println(&quot;环绕前&quot;);

        Signature signature = jp.getSignature();// 获得签名
        System.out.println(&quot;signature:&quot;+signature);

        Object proceed = jp.proceed(); //执行方法

        System.out.println(&quot;环绕后&quot;);

        System.out.println(proceed);
    &#125;

&#125;
</code></pre>
<ol start="2">
<li>在Spring配置文件中，注册bean，并增加支持注解的配置。</li>
</ol>
<pre><code class="xml">    &lt;!--方式三：使用注解--&gt;
    &lt;bean id=&quot;annotationPointCut&quot; class=&quot;com.kuang.diy.AnnotationPointCut&quot;/&gt;
    &lt;!--开启注解支持！ JDK(默认是 proxy-target-class=&quot;false&quot;)  cglib（proxy-target-class=&quot;true&quot;）--&gt;
    &lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<ol start="3">
<li><p>测试</p>
<pre><code class="java">public class MyTest &#123;
    public static void main(String[] args) &#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //动态代理代理的是接口 : 注意点
        UserService userService = (UserService) context.getBean(&quot;userServiceImpl&quot;);

        userService.add();
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h2 id="12、整合Mybatis"><a href="#12、整合Mybatis" class="headerlink" title="12、整合Mybatis"></a>12、整合Mybatis</h2><p>步骤：</p>
<ol>
<li>导入相关jar包<ul>
<li>junit</li>
<li>mybatis</li>
<li>mysql数据库</li>
<li>spring相关</li>
<li>aop织入器</li>
<li>mybatis-spring整合包【重点】在此还导入了lombok包。</li>
<li>配置Maven静态资源过滤问题！</li>
</ul>
</li>
</ol>
<pre><code class="xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--Spring操作数据库的话，还需要一个spring-jdbc
               --&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.8.13&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;2.0.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.10&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;true&lt;/filtering&gt;
            &lt;/resource&gt;
    &lt;/build&gt;
折叠 
</code></pre>
<ol>
<li>编写配置文件</li>
<li>测试</li>
</ol>
<h3 id="12-1-回忆mybatis"><a href="#12-1-回忆mybatis" class="headerlink" title="12.1 回忆mybatis"></a>12.1 回忆mybatis</h3><ol>
<li><p>编写pojo实体类</p>
<pre><code class="java">@Data
public class User &#123;
    private int id;
    private String name;
    private String pwd;
&#125;
</code></pre>
</li>
<li><p>编写实现mybatis的配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
       PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
       &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

   &lt;typeAliases&gt;
       &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
   &lt;/typeAliases&gt;

   &lt;environments default=&quot;development&quot;&gt;
       &lt;environment id=&quot;development&quot;&gt;
           &lt;transactionManager type=&quot;JDBC&quot;/&gt;
           &lt;dataSource type=&quot;POOLED&quot;&gt;
               &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
               &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt;
               &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
               &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
           &lt;/dataSource&gt;
       &lt;/environment&gt;
   &lt;/environments&gt;

   &lt;mappers&gt;
       &lt;package name=&quot;com.kuang.dao&quot;/&gt;
   &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
</li>
<li><p>编写UserMapper接口</p>
<pre><code class="java">public interface UserMapper &#123;
    public List&lt;User&gt; selectUser();
&#125;
</code></pre>
</li>
<li><p>编写UserMapper.xml文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.kuang.mapper.UserMapper&quot;&gt;

    &lt;!--sql--&gt;
    &lt;select id=&quot;selectUser&quot; resultType=&quot;user&quot;&gt;
        select * from mybatis.user
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">@Test
public void selectUser() throws IOException &#123;

   String resource = &quot;mybatis-config.xml&quot;;
   InputStream inputStream = Resources.getResourceAsStream(resource);
   SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
   SqlSession sqlSession = sqlSessionFactory.openSession();

   UserMapper mapper = sqlSession.getMapper(UserMapper.class);

   List&lt;User&gt; userList = mapper.selectUser();
   for (User user: userList)&#123;
       System.out.println(user);
  &#125;

   sqlSession.close();
&#125;
</code></pre>
</li>
</ol>
<h3 id="12-2-Mybatis-Spring"><a href="#12-2-Mybatis-Spring" class="headerlink" title="12.2 Mybatis-Spring"></a>12.2 Mybatis-Spring</h3><p>什么是MyBatis-Spring？</p>
<p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。</p>
<p>文档链接：<a target="_blank" rel="noopener" href="http://mybatis.org/spring/zh/index.html">http://mybatis.org/spring/zh/index.html</a></p>
<p>如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p>
<pre><code class="xml">        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;2.0.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p><strong>整合实现一：</strong></p>
<ol>
<li>引入Spring配置文件spring-dao.xml</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd

&lt;/beans&gt;
</code></pre>
<ol>
<li>配置数据源替换mybaits的数据源</li>
</ol>
<pre><code class="xml">    &lt;!--DataSource:使用Spring的数据源替换Mybatis的配置 c3p0 dbcp druid
    我们这里使用Spring提供的JDBC：--&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<ol>
<li>配置SqlSessionFactory，关联MyBatis</li>
</ol>
<pre><code class="xml">    &lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;!--关联mybatis配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/kuang/mapper/*.xml&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<ol>
<li>注册sqlSessionTemplate，关联sqlSessionFactory</li>
</ol>
<pre><code class="xml">    &lt;!--SqlSessionTemplate:就是我们使用的sqlSession--&gt;
    &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
        &lt;!--只能使用构造器注入sqlSessionFactory，因为它没有set方法--&gt;
        &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
    &lt;/bean&gt;
</code></pre>
<ol>
<li>需要UserMapper接口的UserMapperImpl 实现类，私有化sqlSessionTemplate</li>
</ol>
<pre><code class="java">public class UserMapperImpl implements UserMapper &#123;

    //我们的所有操作，都使用sqlSession来执行，在原来，现在都使用SqlsessionTemplate
    private SqlSessionTemplate sqlSession;

    public void setSqlSession(SqlSessionTemplate sqlSession) &#123;
        this.sqlSession = sqlSession;
    &#125;

    public List&lt;User&gt; selectUser() &#123;
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return mapper.selectUser();
    &#125;
&#125;
</code></pre>
<ol>
<li>将自己写的实现类，注入到Spring配置文件中。</li>
</ol>
<pre><code class="xml">    &lt;bean id=&quot;userMapper&quot; class=&quot;com.kuang.mapper.UserMapperImpl&quot;&gt;
        &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;
    &lt;/bean&gt;
</code></pre>
<ol>
<li>测试使用即可！</li>
</ol>
<pre><code class="java">    @Test
    public void test () throws IOException &#123;

        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dao.xml&quot;);
        
        UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class);
        for (User user : userMapper.selectUser()) &#123;
            System.out.println(user);
        &#125;
    &#125;
</code></pre>
<p>结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！</p>
<pre><code class="xml">结果成功输出！现在我们的Mybatis配置文件的状态！发现都可以被Spring整合！

&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;!--configuration core file--&gt;
&lt;configuration&gt;
    
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
    &lt;/typeAliases&gt;

&lt;/configuration&gt;
</code></pre>
<p><strong>整合实现二：</strong></p>
<p>mybatis-spring1.2.3版以上的才有这个，官方文档截图：</p>
<p>dao继承Support类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory . 比起整合方式一 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/20201122213331963.png" alt="20201122213331963"></p>
<ol>
<li>将我们上面写的UserMapperImpl修改一下</li>
</ol>
<pre><code class="java">public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper &#123;

    public List&lt;User&gt; selectUser() &#123;
        
        return getSqlSession().getMapper(UserMapper.class).selectUser();
    &#125;
&#125;
</code></pre>
<ol start="2">
<li>注入到Spring配置文件中。</li>
</ol>
<pre><code class="xml">    &lt;bean id=&quot;userMapper&quot; class=&quot;com.kuang.mapper.UserMapperImpl&quot;&gt;
        &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
    &lt;/bean&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="java">    @Test
    public void test () throws IOException &#123;

        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-dao.xml&quot;);
        
        UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class);
        for (User user : userMapper.selectUser()) &#123;
            System.out.println(user);
        &#125;
    &#125;
</code></pre>
<h2 id="13、声明式事务"><a href="#13、声明式事务" class="headerlink" title="13、声明式事务"></a>13、声明式事务</h2><h3 id="13-1-回顾事务"><a href="#13-1-回顾事务" class="headerlink" title="13.1 回顾事务"></a>13.1 回顾事务</h3><ul>
<li>把一组业务当成一个业务来做；要么都成功，要么都失败！</li>
<li>事务在项目开发中，十分的重要，涉及到数据的一致性问题，不能马虎！</li>
<li>确保完整性和一致性。</li>
</ul>
<p><strong>事务ACID原则：</strong></p>
<ul>
<li>原子性（atomicity）<ul>
<li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用。</li>
</ul>
</li>
<li>一致性（consistency）<ul>
<li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中。</li>
</ul>
</li>
<li>隔离性（isolation）<ul>
<li>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</li>
</ul>
</li>
<li>持久性（durability）<ul>
<li>事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中。</li>
</ul>
</li>
</ul>
<p><strong>测试：</strong></p>
<p>将上面的代码拷贝到一个新项目中<br>在之前的案例中，我们给userMapper接口新增两个方法，删除和增加用户；</p>
<pre><code class="java">//添加一个用户
int addUser(User user);

//根据id删除用户
int deleteUser(int id);
</code></pre>
<p>UserMapper文件，我们故意把 deletes 写错，测试！</p>
<pre><code class="xml">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)
&lt;/insert&gt;

&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
deletes from user where id = #&#123;id&#125;
&lt;/delete&gt;
</code></pre>
<p>编写接口的UserMapperImpl实现类，在实现类中，我们去操作一波</p>
<pre><code class="java">public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper &#123;


    //增加一些操作
    public List&lt;User&gt; selectUser() &#123;
        User user = new User(5, &quot;小王&quot;, &quot;185161&quot;);
        UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
        mapper.addUser(user);
        mapper.deleteUser(5);

        return mapper.selectUser();
    &#125;
    
    //新增
    public int addUser(User user) &#123;
        return getSqlSession().getMapper(UserMapper.class).addUser(user);
    &#125;

    //删除
    public int deleteUser(int id) &#123;
        return getSqlSession().getMapper(UserMapper.class).deleteUser(id);
    &#125;
&#125;
</code></pre>
<p>测试</p>
<pre><code class="java">    @Test
    public void test()&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

        UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class);

        for (User user : userMapper.selectUser()) &#123;
            System.out.println(user);
        &#125;
    &#125;
</code></pre>
<p>报错：sql异常，delete写错了</p>
<p>结果 ：数据库结果显示插入成功！</p>
<p>没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要事务！</p>
<p>以前我们都需要自己手动管理事务，十分麻烦！</p>
<p>但是Spring给我们提供了事务管理，我们只需要配置即可；</p>
<h3 id="13-2-Spring中的事务管理"><a href="#13-2-Spring中的事务管理" class="headerlink" title="13.2 Spring中的事务管理"></a>13.2 Spring中的事务管理</h3><p>Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p>
<p><strong>编程式事务管理</strong></p>
<ul>
<li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li>
<li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li>
</ul>
<p><strong>声明式事务管理</strong></p>
<ul>
<li>一般情况下比编程式事务好用。</li>
<li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li>
<li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。</li>
</ul>
<p><strong>1. 使用Spring管理事务，注意头文件的约束导入 : tx</strong></p>
<pre><code class="xml">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;

http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
</code></pre>
<p><strong>2. JDBC事务</strong></p>
<pre><code class="xml">&lt;!--配置声明式事务--&gt;
&lt;bean id=&quot;transactionManger&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
      &lt;constructor-arg ref=&quot;datasource&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>3. 配置好事务管理器后我们需要去配置事务的通知</strong></p>
<pre><code class="xml">    &lt;!--结合AOP实现事务的织入--&gt;
    &lt;!--配置事务通知--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;!--给那些方法配置事务--&gt;
        &lt;!--配置事务的传播特性： new --&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;query&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
</code></pre>
<p><strong>spring事务传播特性：</strong><br>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p>
<ul>
<li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作。</li>
</ul>
<p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p>
<p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p>
<p><strong>4. 配置AOP，导入aop的头文件</strong></p>
<pre><code class="xml">    &lt;!--配置事务切入--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.kuang.mapper.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;
    &lt;/aop:config&gt;
</code></pre>
<p><strong>5. 删掉刚才插入的数据，再次测试！</strong></p>
<pre><code class="java">    @Test
    public void test()&#123;
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

        UserMapper userMapper = context.getBean(&quot;userMapper&quot;, UserMapper.class);

        for (User user : userMapper.selectUser()) &#123;
            System.out.println(user);
        &#125;
    &#125;
</code></pre>
<p><strong>思考：</strong></p>
<p>为什么需要事务？</p>
<ul>
<li>如果不配置事务，可能存在数据提交不一致的情况；</li>
<li>如果我们不在Spring中去配置声明式事务，我们就需要在代码中手动配置事务！</li>
<li>事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不容马虎！</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #ff7d73">
                SSM
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Spring/" style="color: #03a9f4">
                Spring
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/Spring_狂神说/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/18/mybatis_狂神说/">
        <h2 class="post-title">Mybatis_狂神说</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/SSM/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                SSM
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="Mybatis-9-28"><a href="#Mybatis-9-28" class="headerlink" title="Mybatis-9.28"></a>Mybatis-9.28</h1><p>环境：</p>
<ul>
<li>JDK1.8</li>
<li>Mysql 5.7</li>
<li>maven 3.6.1</li>
<li>IDEA</li>
</ul>
<p>回顾：</p>
<ul>
<li>JDBC</li>
<li>Mysql</li>
<li>Java基础</li>
<li>Maven</li>
<li>Junit</li>
</ul>
<p>SSM框架：配置文件的。 最好的方式：看官网文档；</p>
<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><h3 id="1-1、什么是Mybatis"><a href="#1-1、什么是Mybatis" class="headerlink" title="1.1、什么是Mybatis"></a>1.1、什么是Mybatis</h3><p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/mybatis-superbird-small.png" alt="img"></p>
<ul>
<li>MyBatis 是一款优秀的<strong>持久层框架</strong></li>
<li>它支持定制化 SQL、存储过程以及高级映射。</li>
<li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li>
<li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li>
<li>MyBatis 本是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/apache/6265">apache</a>的一个开源项目<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/iBatis">iBatis</a>, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。</li>
<li>2013年11月迁移到Github。</li>
</ul>
<p>如何获得Mybatis？</p>
<ul>
<li><p>maven仓库：</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.5.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>Github ： <a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3/releases">https://github.com/mybatis/mybatis-3/releases</a></p>
</li>
<li><p>中文文档：<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p>
</li>
</ul>
<h3 id="1-2、持久化"><a href="#1-2、持久化" class="headerlink" title="1.2、持久化"></a>1.2、持久化</h3><p>数据持久化</p>
<ul>
<li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</li>
<li>内存：<strong>断电即失</strong></li>
<li>数据库(Jdbc)，io文件持久化。</li>
<li>生活：冷藏. 罐头。</li>
</ul>
<p><strong>为什么需要需要持久化？</strong></p>
<ul>
<li>有一些对象，不能让他丢掉。</li>
<li>内存太贵了</li>
</ul>
<h3 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h3><p>Dao层，Service层，Controller层….</p>
<ul>
<li>完成持久化工作的代码块</li>
<li>层界限十分明显。</li>
</ul>
<h3 id="1-4-为什么需要Mybatis？"><a href="#1-4-为什么需要Mybatis？" class="headerlink" title="1.4 为什么需要Mybatis？"></a>1.4 为什么需要Mybatis？</h3><ul>
<li>帮助程序猿将数据存入到数据库中。</li>
<li>方便</li>
<li>传统的JDBC代码太复杂了。简化。框架。自动化。</li>
<li>不用Mybatis也可以。更容易上手。 <strong>技术没有高低之分</strong></li>
<li>优点：<ul>
<li>简单易学</li>
<li>灵活</li>
<li>sql和代码的分离，提高了可维护性。</li>
<li>提供映射标签，支持对象与数据库的orm字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供xml标签，支持编写动态sql。</li>
</ul>
</li>
</ul>
<p><strong>最重要的一点：使用的人多！</strong></p>
<p>Spring SpringMVC SpringBoot</p>
<h2 id="2、第一个Mybatis程序"><a href="#2、第一个Mybatis程序" class="headerlink" title="2、第一个Mybatis程序"></a>2、第一个Mybatis程序</h2><p>思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试</p>
<h3 id="2-1、搭建环境"><a href="#2-1、搭建环境" class="headerlink" title="2.1、搭建环境"></a>2.1、搭建环境</h3><p>搭建数据库</p>
<pre><code class="sql">CREATE DATABASE `mybatis`;

USE `mybatis`;

CREATE TABLE `user`(
  `id` INT(20) NOT NULL PRIMARY KEY,
  `name` VARCHAR(30) DEFAULT NULL,
  `pwd` VARCHAR(30) DEFAULT NULL
)ENGINE=INNODB DEFAULT CHARSET=utf8;

INSERT INTO `user`(`id`,`name`,`pwd`) VALUES 
(1,&#39;狂神&#39;,&#39;123456&#39;),
(2,&#39;张三&#39;,&#39;123456&#39;),
(3,&#39;李四&#39;,&#39;123890&#39;)
</code></pre>
<p>新建项目</p>
<ol>
<li><p>新建一个普通的maven项目</p>
</li>
<li><p>删除src目录</p>
</li>
<li><p>导入maven依赖</p>
<pre><code class="xml">
    &lt;!--导入依赖--&gt;
    &lt;dependencies&gt;
        &lt;!--mysql驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis--&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--junit--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
</li>
</ol>
<h3 id="2-2、创建一个模块"><a href="#2-2、创建一个模块" class="headerlink" title="2.2、创建一个模块"></a>2.2、创建一个模块</h3><ul>
<li><p>编写mybatis的核心配置文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;!--configuration核心配置文件--&gt;
&lt;configuration&gt;

    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;mysql0917&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

&lt;/configuration&gt;
</code></pre>
</li>
<li><p>编写mybatis工具类</p>
<pre><code class="java">//sqlSessionFactory --&gt; sqlSession
public class MybatisUtils &#123;

    private static SqlSessionFactory sqlSessionFactory;

    static&#123;
        try &#123;
            //使用Mybatis第一步：获取sqlSessionFactory对象
            String resource = &quot;mybatis-config.xml&quot;;
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;

    &#125;

    //既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。
    // SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。
    public static SqlSession  getSqlSession()&#123;
        return sqlSessionFactory.openSession();
    &#125;

&#125;

</code></pre>
</li>
</ul>
<h3 id="2-3、编写代码"><a href="#2-3、编写代码" class="headerlink" title="2.3、编写代码"></a>2.3、编写代码</h3><ul>
<li><p>实体类</p>
<pre><code class="java">package com.kuang.pojo;

//实体类
public class User &#123;
    private int id;
    private String name;
    private String pwd;

    public User() &#123;
    &#125;

    public User(int id, String name, String pwd) &#123;
        this.id = id;
        this.name = name;
        this.pwd = pwd;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getPwd() &#123;
        return pwd;
    &#125;

    public void setPwd(String pwd) &#123;
        this.pwd = pwd;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, pwd=&#39;&quot; + pwd + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;

折叠 
</code></pre>
</li>
<li><p>Dao接口</p>
<pre><code class="java">public interface UserDao &#123;
    List&lt;User&gt; getUserList();
&#125;
</code></pre>
</li>
<li><p>接口实现类由原来的UserDaoImpl转变为一个 Mapper配置文件.</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE mapper
                PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
                &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        &lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;
&lt;mapper namespace=&quot;com.kuang.dao.UserDao&quot;&gt;

&lt;!--select查询语句--&gt;
   &lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
       select * from mybatis.user
   &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
</li>
</ul>
<h3 id="2-4、测试"><a href="#2-4、测试" class="headerlink" title="2.4、测试"></a>2.4、测试</h3><p>注意点：</p>
<p>org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry.</p>
<p><strong>MapperRegistry是什么？</strong></p>
<p>核心配置文件中注册 mappers</p>
<ul>
<li><p>junit测试</p>
<pre><code class="java">@Test
public void test()&#123;
    //第一步：获得SqlSession对象
    SqlSession sqlSession = MybatisUtils.getSqlSession();


    //方式一：getMapper
    UserDao userDao = sqlSession.getMapper(UserDao.class);
    List&lt;User&gt; userList = userDao.getUserList();

    for (User user : userList) &#123;
        System.out.println(user);
    &#125;



    //关闭SqlSession
    sqlSession.close();
&#125;
</code></pre>
</li>
</ul>
<p>你们可以能会遇到的问题：</p>
<ol>
<li>配置文件没有注册</li>
<li>绑定接口错误。</li>
<li>方法名不对</li>
<li>返回类型不对</li>
<li>Maven导出资源问题</li>
</ol>
<h2 id="3、CRUD"><a href="#3、CRUD" class="headerlink" title="3、CRUD"></a>3、CRUD</h2><h3 id="1、namespace"><a href="#1、namespace" class="headerlink" title="1、namespace"></a>1、namespace</h3><p>namespace中的包名要和 Dao&#x2F;mapper 接口的包名一致！</p>
<h3 id="2、select"><a href="#2、select" class="headerlink" title="2、select"></a>2、select</h3><p>选择，查询语句;</p>
<ul>
<li>id : 就是对应的namespace中的方法名；</li>
<li>resultType：Sql语句执行的返回值！</li>
<li>parameterType ： 参数类型！</li>
</ul>
<ol>
<li><p>编写接口</p>
<pre><code class="java">//根据ID查询用户
User getUserById(int id);
</code></pre>
</li>
<li><p>编写对应的mapper中的sql语句</p>
<pre><code class="java">&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
        select * from mybatis.user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">    @Test
    public void getUserById() &#123;
        SqlSession sqlSession = MybatisUtils.getSqlSession();

        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        User user = mapper.getUserById(1);
        System.out.println(user);

        sqlSession.close();
    &#125;
</code></pre>
</li>
</ol>
<h3 id="3、Insert"><a href="#3、Insert" class="headerlink" title="3、Insert"></a>3、Insert</h3><pre><code class="xml">    &lt;!--对象中的属性，可以直接取出来--&gt;
    &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
        insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);
    &lt;/insert&gt;
</code></pre>
<h3 id="4、update"><a href="#4、update" class="headerlink" title="4、update"></a>4、update</h3><pre><code class="xml">    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt;
        update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125;  where id = #&#123;id&#125; ;
    &lt;/update&gt;
</code></pre>
<h3 id="5、Delete"><a href="#5、Delete" class="headerlink" title="5、Delete"></a>5、Delete</h3><pre><code class="xml">    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
        delete from mybatis.user where id = #&#123;id&#125;;
    &lt;/delete&gt;
</code></pre>
<p>注意点：</p>
<ul>
<li>增删改需要提交事务！</li>
</ul>
<h3 id="6、分析错误"><a href="#6、分析错误" class="headerlink" title="6、分析错误"></a>6、分析错误</h3><ul>
<li>标签不要匹配错</li>
<li>resource 绑定mapper，需要使用路径！</li>
<li>程序配置文件必须符合规范！</li>
<li>NullPointerException，没有注册到资源!</li>
<li>输出的xml文件中存在中文乱码问题！</li>
<li>maven资源没有导出问题！</li>
</ul>
<h3 id="7、万能Map"><a href="#7、万能Map" class="headerlink" title="7、万能Map"></a>7、万能Map</h3><p>假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！</p>
<pre><code class="java">    //万能的Map
    int addUser2(Map&lt;String,Object&gt; map);
    &lt;!--对象中的属性，可以直接取出来    传递map的key--&gt;
    &lt;insert id=&quot;addUser&quot; parameterType=&quot;map&quot;&gt;
        insert into mybatis.user (id, pwd) values (#&#123;userid&#125;,#&#123;passWord&#125;);
    &lt;/insert&gt;
    @Test
    public void addUser2()&#123;
        SqlSession sqlSession = MybatisUtils.getSqlSession();

        UserMapper mapper = sqlSession.getMapper(UserMapper.class);


        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();

        map.put(&quot;userid&quot;,5);
        map.put(&quot;passWord&quot;,&quot;2222333&quot;);

        mapper.addUser2(map);

        sqlSession.close();
    &#125;
</code></pre>
<p>Map传递参数，直接在sql中取出key即可！ 【parameterType&#x3D;”map”】</p>
<p>对象传递参数，直接在sql中取对象的属性即可！【parameterType&#x3D;”Object”】</p>
<p>只有一个基本类型参数的情况下，可以直接在sql中取到！</p>
<p>多个参数用Map，<strong>或者注解！</strong></p>
<h3 id="8、思考题"><a href="#8、思考题" class="headerlink" title="8、思考题"></a>8、思考题</h3><p>模糊查询怎么写？</p>
<ol>
<li><p>Java代码执行的时候，传递通配符 % %</p>
<pre><code class="java">List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;);
</code></pre>
</li>
<li><p>在sql拼接中使用通配符！</p>
<pre><code class="java">select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;
</code></pre>
</li>
</ol>
<h2 id="4、配置解析"><a href="#4、配置解析" class="headerlink" title="4、配置解析"></a>4、配置解析</h2><h3 id="1、核心配置文件"><a href="#1、核心配置文件" class="headerlink" title="1、核心配置文件"></a>1、核心配置文件</h3><ul>
<li><p>mybatis-config.xml</p>
</li>
<li><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</p>
<pre><code class="xml">configuration（配置）
properties（属性）
settings（设置）
typeAliases（类型别名）
typeHandlers（类型处理器）
objectFactory（对象工厂）
plugins（插件）
environments（环境配置）
environment（环境变量）
transactionManager（事务管理器）
dataSource（数据源）
databaseIdProvider（数据库厂商标识）
mappers（映射器）
</code></pre>
</li>
</ul>
<h3 id="2、环境配置（environments）"><a href="#2、环境配置（environments）" class="headerlink" title="2、环境配置（environments）"></a>2、环境配置（environments）</h3><p>MyBatis 可以配置成适应多种环境</p>
<p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p>
<p>学会使用配置多套运行环境！</p>
<p>Mybatis默认的事务管理器就是 JDBC ， 连接池 ： POOLED</p>
<h3 id="3、属性（properties）"><a href="#3、属性（properties）" class="headerlink" title="3、属性（properties）"></a>3、属性（properties）</h3><p>我们可以通过properties属性来实现引用配置文件</p>
<p>这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。	    【db.properties】</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132425014-1129829737.png" alt="1569656528134"></p>
<p>编写一个配置文件</p>
<p>db.properties</p>
<pre><code class="properties">driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8
username=root
password=mysql0917
</code></pre>
<p>在核心配置文件中映入</p>
<pre><code class="xml">    &lt;!--引入外部配置文件--&gt;
    &lt;properties resource=&quot;db.properties&quot;&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;pwd&quot; value=&quot;11111&quot;/&gt;
    &lt;/properties&gt;
</code></pre>
<ul>
<li>可以直接引入外部文件</li>
<li>可以在其中增加一些属性配置</li>
<li>如果两个文件有同一个字段，优先使用外部配置文件的！</li>
</ul>
<h3 id="4、类型别名（typeAliases）"><a href="#4、类型别名（typeAliases）" class="headerlink" title="4、类型别名（typeAliases）"></a>4、类型别名（typeAliases）</h3><ul>
<li>类型别名是为 Java 类型设置一个短的名字。‘</li>
<li>存在的意义仅在于用来减少类完全限定名的冗余。</li>
</ul>
<pre><code class="xml">    &lt;!--可以给实体类起别名--&gt;
    &lt;typeAliases&gt;
        &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;
    &lt;/typeAliases&gt;
</code></pre>
<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p>
<p>扫描实体类的包，它的默认别名就为这个类的 类名，首字母小写！</p>
<pre><code class="xml">&lt;!--可以给实体类起别名--&gt;
&lt;typeAliases&gt;
    &lt;package name=&quot;com.kuang.pojo&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>在实体类比较少的时候，使用第一种方式。</p>
<p>如果实体类十分多，建议使用第二种。</p>
<p>第一种可以DIY别名，第二种则·不行·，如果非要改，需要在实体上增加注解</p>
<pre><code class="java">@Alias(&quot;user&quot;)
public class User &#123;&#125;
</code></pre>
<h3 id="5、设置"><a href="#5、设置" class="headerlink" title="5、设置"></a>5、设置</h3><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132425295-455086798.png" alt="1569657659080"></p>
<p><img src="/assets/mybatiskuangsheng/2084540-20200916132425509-1329526048.png" alt="1569657672791"></p>
<h3 id="6、其他配置"><a href="#6、其他配置" class="headerlink" title="6、其他配置"></a>6、其他配置</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li>
<li>plugins插件<ul>
<li>mybatis-generator-core</li>
<li>mybatis-plus</li>
<li>通用mapper</li>
</ul>
</li>
</ul>
<h3 id="7、映射器（mappers）"><a href="#7、映射器（mappers）" class="headerlink" title="7、映射器（mappers）"></a>7、映射器（mappers）</h3><p>MapperRegistry：注册绑定我们的Mapper文件；</p>
<p>方式一： 【推荐使用】</p>
<pre><code class="xml">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;com/kuang/dao/UserMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>方式二：使用class文件绑定注册</p>
<pre><code class="xml">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;
&lt;mappers&gt;
    &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>注意点：</p>
<ul>
<li>接口和他的Mapper配置文件必须同名！</li>
<li>接口和他的Mapper配置文件必须在同一个包下！</li>
</ul>
<p>方式三：使用扫描包进行注入绑定</p>
<pre><code class="xml">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;
&lt;mappers&gt;
    &lt;package name=&quot;com.kuang.dao&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>注意点：</p>
<ul>
<li>接口和他的Mapper配置文件必须同名！</li>
<li>接口和他的Mapper配置文件必须在同一个包下！</li>
</ul>
<p>练习时间：</p>
<ul>
<li>将数据库配置文件外部引入</li>
<li>实体类别名</li>
<li>保证UserMapper 接口 和 UserMapper .xml 改为一致！并且放在同一个包下！</li>
</ul>
<h3 id="8、生命周期和作用域"><a href="#8、生命周期和作用域" class="headerlink" title="8、生命周期和作用域"></a>8、生命周期和作用域</h3><p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132425710-1579637144.png" alt="1569660357745"></p>
<p>生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong>。</p>
<p><strong>SqlSessionFactoryBuilder：</strong></p>
<ul>
<li>一旦创建了 SqlSessionFactory，就不再需要它了</li>
<li>局部变量</li>
</ul>
<p><strong>SqlSessionFactory：</strong></p>
<ul>
<li>说白了就是可以想象为 ：数据库连接池</li>
<li>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例。</strong></li>
<li>因此 SqlSessionFactory 的最佳作用域是应用作用域。</li>
<li>最简单的就是使用<strong>单例模式</strong>或者静态单例模式。</li>
</ul>
<p><strong>SqlSession</strong></p>
<ul>
<li>连接到连接池的一个请求！</li>
<li>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。</li>
<li>用完之后需要赶紧关闭，否则资源被占用！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132425892-1365646093.png" alt="1569660737088"></p>
<p>这里面的每一个Mapper，就代表一个具体的业务！</p>
<h2 id="5、解决属性名和字段名不一致的问题"><a href="#5、解决属性名和字段名不一致的问题" class="headerlink" title="5、解决属性名和字段名不一致的问题"></a>5、解决属性名和字段名不一致的问题</h2><h3 id="1、-问题"><a href="#1、-问题" class="headerlink" title="1、 问题"></a>1、 问题</h3><p>数据库中的字段</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132426065-922439632.png" alt="1569660831076"></p>
<p>新建一个项目，拷贝之前的，测试实体类字段不一致的情况</p>
<pre><code class="java">public class User &#123;
    
    private int id;
    private String name;
    private String password;
&#125;
</code></pre>
<p>测试出现问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132426229-957403968.png" alt="1569661145806"></p>
<pre><code class="xml">//    select * from mybatis.user where id = #&#123;id&#125;
//类型处理器
//    select id,name,pwd from mybatis.user where id = #&#123;id&#125;
</code></pre>
<p>解决方法：</p>
<ul>
<li><p>起别名</p>
<pre><code class="xml">&lt;select id=&quot;getUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt;
    select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
</li>
</ul>
<h3 id="2、resultMap"><a href="#2、resultMap" class="headerlink" title="2、resultMap"></a>2、resultMap</h3><p>结果集映射</p>
<pre><code class="bash">id   name   pwd
id   name   password
&lt;!--结果集映射--&gt;
&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
    &lt;!--column数据库中的字段，property实体类中的属性--&gt;
    &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot;&gt;
    select * from mybatis.user where id = #&#123;id&#125;
&lt;/select&gt;
</code></pre>
<ul>
<li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素</li>
<li>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。</li>
<li><code>ResultMap</code> 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。</li>
<li>如果世界总是这么简单就好了。</li>
</ul>
<h2 id="6、日志"><a href="#6、日志" class="headerlink" title="6、日志"></a>6、日志</h2><h3 id="6-1、日志工厂"><a href="#6-1、日志工厂" class="headerlink" title="6.1、日志工厂"></a>6.1、日志工厂</h3><p>如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！</p>
<p>曾经：sout 、debug</p>
<p>现在：日志工厂！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132426391-662536759.png" alt="1569892155104"></p>
<ul>
<li>SLF4J</li>
<li>LOG4J 【掌握】</li>
<li>LOG4J2</li>
<li>JDK_LOGGING</li>
<li>COMMONS_LOGGING</li>
<li>STDOUT_LOGGING 【掌握】</li>
<li>NO_LOGGING</li>
</ul>
<p>在Mybatis中具体使用那个一日志实现，在设置中设定！</p>
<p><strong>STDOUT_LOGGING标准日志输出</strong></p>
<p>在mybatis核心配置文件中，配置我们的日志！</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132426595-1023620136.png" alt="1569892595060"></p>
<h3 id="6-2、Log4j"><a href="#6-2、Log4j" class="headerlink" title="6.2、Log4j"></a>6.2、Log4j</h3><p>什么是Log4j？</p>
<ul>
<li>Log4j是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626">控制台</a>、文件、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/GUI">GUI</a>组件</li>
<li>我们也可以控制每一条日志的输出格式；</li>
<li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</li>
<li>通过一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</li>
</ul>
<ol>
<li><p>先导入log4j的包</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>log4j.properties</p>
<pre><code class="properties">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/kuang.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n

#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
</code></pre>
</li>
<li><p>配置log4j为日志的实现</p>
<pre><code class="xml">&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;&quot;/&gt;
&lt;/settings&gt;
</code></pre>
</li>
<li><p>Log4j的使用！，直接测试运行刚才的查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132426821-1121850478.png" alt="1569893505842"></p>
</li>
</ol>
<p><strong>简单使用</strong></p>
<ol>
<li><p>在要使用Log4j 的类中，导入包 import org.apache.log4j.Logger;</p>
</li>
<li><p>日志对象，参数为当前类的class</p>
<pre><code class="java">static Logger logger = Logger.getLogger(UserDaoTest.class);
</code></pre>
</li>
<li><p>日志级别</p>
<pre><code class="java">logger.info(&quot;info:进入了testLog4j&quot;);
logger.debug(&quot;debug:进入了testLog4j&quot;);
logger.error(&quot;error:进入了testLog4j&quot;);
</code></pre>
</li>
</ol>
<h2 id="7、分页"><a href="#7、分页" class="headerlink" title="7、分页"></a>7、分页</h2><p><strong>思考：为什么要分页？</strong></p>
<ul>
<li>减少数据的处理量</li>
</ul>
<h3 id="7-1、使用Limit分页"><a href="#7-1、使用Limit分页" class="headerlink" title="7.1、使用Limit分页"></a>7.1、使用Limit分页</h3><pre><code class="sql">语法：SELECT * from user limit startIndex,pageSize;
SELECT * from user limit 3;  #[0,n]
</code></pre>
<p>使用Mybatis实现分页，核心SQL</p>
<ol>
<li><p>接口</p>
<pre><code class="java">//分页
List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map);
</code></pre>
</li>
<li><p>Mapper.xml</p>
<pre><code class="xml">&lt;!--//分页--&gt;
&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt;
    select * from  mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;
&lt;/select&gt;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">@Test
public void getUserByLimit()&#123;
SqlSession sqlSession = MybatisUtils.getSqlSession();
UserMapper mapper = sqlSession.getMapper(UserMapper.class);

HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
    map.put(&quot;startIndex&quot;,1);
    map.put(&quot;pageSize&quot;,2);

    List&lt;User&gt; userList =  mapper.getUserByLimit(map);
    for (User user : userList) &#123;
    System.out.println(user);
    &#125;

    sqlSession.close();
    &#125;
</code></pre>
</li>
</ol>
<h3 id="7-2、RowBounds分页"><a href="#7-2、RowBounds分页" class="headerlink" title="7.2、RowBounds分页"></a>7.2、RowBounds分页</h3><p>不再使用SQL实现分页</p>
<ol>
<li><p>接口</p>
<pre><code class="java">//分页2
List&lt;User&gt; getUserByRowBounds();
</code></pre>
</li>
<li><p>mapper.xml</p>
<pre><code class="xml">&lt;!--分页2--&gt;
&lt;select id=&quot;getUserByRowBounds&quot; resultMap=&quot;UserMap&quot;&gt;
    select * from  mybatis.user
&lt;/select&gt;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">@Test
public void getUserByRowBounds()&#123;
SqlSession sqlSession = MybatisUtils.getSqlSession();

//RowBounds实现
RowBounds rowBounds = new RowBounds(1, 2);

//通过Java代码层面实现分页
List&lt;User&gt; userList = sqlSession.selectList(&quot;com.kuang.dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds);

    for (User user : userList) &#123;
    System.out.println(user);
    &#125;

    sqlSession.close();
    &#125;
</code></pre>
</li>
</ol>
<h3 id="7-3、分页插件"><a href="#7-3、分页插件" class="headerlink" title="7.3、分页插件"></a>7.3、分页插件</h3><p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132427106-481754588.png" alt="1569896603103"></p>
<p>了解即可，万一 以后公司的架构师，说要使用，你需要知道它是什么东西！</p>
<h2 id="8、使用注解开发"><a href="#8、使用注解开发" class="headerlink" title="8、使用注解开发"></a>8、使用注解开发</h2><h3 id="8-1、面向接口编程"><a href="#8-1、面向接口编程" class="headerlink" title="8.1、面向接口编程"></a>8.1、面向接口编程</h3><p>- 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程<br>- <strong>根本原因 : &#x3D;&#x3D;解耦&#x3D;&#x3D;, 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好</strong><br>- 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；<br>- 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</p>
<p><strong>关于接口的理解</strong></p>
<p>- 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。<br>        - 接口的本身反映了系统设计人员对系统的抽象理解。<br>        - 接口应有两类：<br>        - 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；<br>        - 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；<br>        - 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。</p>
<p><strong>三个面向区别</strong></p>
<p>- 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .<br>- 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .<br>- 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构</p>
<h3 id="8-2、使用注解开发"><a href="#8-2、使用注解开发" class="headerlink" title="8.2、使用注解开发"></a>8.2、使用注解开发</h3><ol>
<li><p>注解在接口上实现</p>
<pre><code class="java">@Select(&quot;select * from user&quot;)
List&lt;User&gt; getUsers();
</code></pre>
</li>
<li><p>需要再核心配置文件中绑定接口！</p>
<pre><code class="xml">&lt;!--绑定接口--&gt;
&lt;mappers&gt;
    &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
</li>
<li><p>测试</p>
</li>
</ol>
<p>本质：反射机制实现</p>
<p>底层：动态代理！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132427311-1737862394.png" alt="1569898830704"></p>
<p><strong>Mybatis详细的执行流程！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/2084540-20200916132427508-886466614.png" alt="1569898830704"></p>
<h3 id="8-3、CRUD"><a href="#8-3、CRUD" class="headerlink" title="8.3、CRUD"></a>8.3、CRUD</h3><p>我们可以在工具类创建的时候实现自动提交事务！</p>
<pre><code class="java">public static SqlSession  getSqlSession()&#123;
    return sqlSessionFactory.openSession(true);
&#125;
</code></pre>
<p>编写接口，增加注解</p>
<pre><code class="java">public interface UserMapper &#123;

    @Select(&quot;select * from user&quot;)
    List&lt;User&gt; getUsers();

    // 方法存在多个参数，所有的参数前面必须加上 @Param(&quot;id&quot;)注解
    @Select(&quot;select * from user where id = #&#123;id&#125;&quot;)
    User getUserByID(@Param(&quot;id&quot;) int id);


    @Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)
    int addUser(User user);

    
    @Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id = #&#123;id&#125;&quot;)
    int updateUser(User user);

    
    @Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;)
    int deleteUser(@Param(&quot;uid&quot;) int id);
&#125;
</code></pre>
<p>测试类</p>
<p>【注意：我们必须要讲接口注册绑定到我们的核心配置文件中！】</p>
<p><strong>关于@Param() 注解</strong></p>
<ul>
<li>基本类型的参数或者String类型，需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一个基本类型的话，可以忽略，但是建议大家都加上！</li>
<li>我们在SQL中引用的就是我们这里的 @Param() 中设定的属性名！</li>
</ul>
<p><strong>#{} ${} 区别</strong></p>
<h2 id="9、Lombok"><a href="#9、Lombok" class="headerlink" title="9、Lombok"></a>9、Lombok</h2><pre><code class="java">Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.
Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.
</code></pre>
<ul>
<li>java library</li>
<li>plugs</li>
<li>build tools</li>
<li>with one annotation your class</li>
</ul>
<p>使用步骤：</p>
<ol>
<li><p>在IDEA中安装Lombok插件！</p>
</li>
<li><p>在项目中导入lombok的jar包</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>在实体类上加注解即可！</p>
<pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
</code></pre>
</li>
</ol>
<pre><code class="java">@Getter and @Setter
@FieldNameConstants
@ToString
@EqualsAndHashCode
@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor
@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger
@Data
@Builder
@Singular
@Delegate
@Value
@Accessors
@Wither
@SneakyThrows
</code></pre>
<p>说明：</p>
<pre><code class="less">@Data：无参构造，get、set、tostring、hashcode，equals
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@ToString
@Getter
</code></pre>
<h2 id="10、多对一处理"><a href="#10、多对一处理" class="headerlink" title="10、多对一处理"></a>10、多对一处理</h2><p>​	多对一：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220710114210927.png" alt="image-20220710114210927"></p>
<ul>
<li>多个学生，对应一个老师</li>
<li>对于学生而言， <strong>关联</strong>..  多个学生，关联一个老师 【多对一】</li>
<li>对于老师而言，<strong>集合</strong>，一个老师，有很多学生 【一对多】</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220710121217911.png" alt="image-20220710121217911"></p>
<p>SQL：</p>
<pre><code class="sql">CREATE TABLE (
    `id` INT(10)	NOT NULL,
    `name` VARCHAR(30) DEFAULT NULL,
    PRIMARY KEY(`id`)
)ENGINE= INNODB DEFAULT CHARSET=utf8

INSERT INTO teacher(`id`,`name`) VALUES (1,&#39;秦老师&#39;);

CREATE TABLE `student`(
    `id` INT(10)	NOT NULL,
    `name` VARCHAR(30) DEFAULT NULL,
    `tid` INT(10) DEFAULT NULL,
    PRIMARY KEY(`id`),
    KEY `fktid` (`tid`),
    CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)
)ENGINE= INNODB DEFAULT CHARSET=utf8

INSERT INTO student(`id`,`name`,`tid`) VALUES (1,&#39;小明&#39;,&#39;1&#39;);
INSERT INTO student(`id`,`name`,`tid`) VALUES (2,&#39;小红&#39;,&#39;1&#39;);
INSERT INTO student(`id`,`name`,`tid`) VALUES (3,&#39;小张&#39;,&#39;1&#39;);
INSERT INTO student(`id`,`name`,`tid`) VALUES (4,&#39;小李&#39;,&#39;1&#39;);
INSERT INTO student(`id`,`name`,`tid`) VALUES (5,&#39;小王&#39;,&#39;1&#39;);
</code></pre>
<h3 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h3><ol>
<li>导入lombok</li>
<li>新建实体类Teacher,Student</li>
<li>建立Mapper接口</li>
<li>建立Mapper.xml文件</li>
<li>在核心配置文件中绑定注册我们的Mapper接口或文件！</li>
<li>测试查询是否能够成功！</li>
</ol>
<h3 id="按照查询嵌套处理"><a href="#按照查询嵌套处理" class="headerlink" title="按照查询嵌套处理"></a>按照查询嵌套处理</h3><pre><code>    &lt;!--
      思路:
        1. 查询所有的学生信息
        2.根据查询出来的学生的tid，寻找对应的老师！  子查询
    --&gt;
    &lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeanher&quot;&gt;
        select * from student
    &lt;/select&gt;

    &lt;resultMap id=&quot;StudentTeanher&quot; type=&quot;Student&quot;&gt;
        &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;
        &lt;!--复杂的属性，我们需要单独处理 对象: association  集合: collection --&gt;
        &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;
    &lt;/resultMap&gt;
    
    &lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot;&gt;
        select * from teacher where id = #&#123;id&#125;
    &lt;/select&gt;
</code></pre>
<h3 id="按照结果嵌套处理"><a href="#按照结果嵌套处理" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h3><pre><code class="xml">   &lt;!--按照结果嵌套处理--&gt;
    &lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt;
        select s.id sid,s.name sname,t.name tname
        from student s,teacher t
        where s.tid = t.id
    &lt;/select&gt;
    &lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt;
        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
        &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;
            &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;
</code></pre>
<p>回顾MySQL 多对一查询方式：</p>
<ul>
<li><p>子查询</p>
</li>
<li><p>联表查询</p>
</li>
</ul>
<h2 id="11、一对多处理"><a href="#11、一对多处理" class="headerlink" title="11、一对多处理"></a>11、一对多处理</h2><p>比如：一个老师拥有多个学生！</p>
<p>对于老师而言，就是一对多的关系！</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><strong>实体类</strong></p>
<pre><code class="java">@Data
public class Teacher &#123;
    private int id;
    private String name;
    
    //一个老师拥有多个学生
    private List&lt;Student&gt; students;
&#125;
</code></pre>
<pre><code class="java">@Data
public class Student &#123;
    private int id;
    private String name;
    private int tid;

&#125;
</code></pre>
<h3 id="按照结果嵌套处理-1"><a href="#按照结果嵌套处理-1" class="headerlink" title="按照结果嵌套处理"></a><strong>按照结果嵌套处理</strong></h3><pre><code class="xml">    &lt;!--按照结果嵌套处理--&gt;
    &lt;select id=&quot;getAllTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt;
        select s.id sid,s.name sname,t.name tname,t.id tid
        from student s,teacher t
        where s.tid = t.id and t.id = #&#123;tid&#125;
    &lt;/select&gt;
    &lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt;
        &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
        &lt;!--复杂的属性，我们需要单独处理 对象: association  集合: collection
            javaType=&quot;&quot; 指定属性的类型！
            集合中的泛型信息，我们使用ofType获取
        --&gt;
        &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;
            &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;
            &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
            &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
</code></pre>
<h3 id="按照查询嵌套处理-1"><a href="#按照查询嵌套处理-1" class="headerlink" title="按照查询嵌套处理"></a><strong>按照查询嵌套处理</strong></h3><pre><code class="xml">&lt;select id=&quot;getAllTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt;
    select * from teacher where id = #&#123;tid&#125;
&lt;/select&gt;
&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt;
    &lt;collection property=&quot;students&quot; column=&quot;id&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudent&quot;/&gt;
&lt;/resultMap&gt;
&lt;select id=&quot;getStudent&quot; resultType=&quot;Student&quot;&gt;
    select * from student where tid = #&#123;tid&#125;
&lt;/select&gt;
</code></pre>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>关联 -association 【多对一】</li>
<li>集合 -collection  【一对多】</li>
<li>javaType  &amp;  ofType<ol>
<li>javaType   用来指定实体类中属性的类型</li>
<li>ofType       用来指定映射到List或者集合中的bean(pojo)类型，泛型中的约束类型！</li>
</ol>
</li>
</ol>
<p>注意点：</p>
<ul>
<li>保证SQL的可读性，尽量保证通俗易懂</li>
<li>注意一对多和多对一中属性名和字段的问题！</li>
<li>如果问题不好排查，可以使用日志，建议使用log4j</li>
</ul>
<p>面试高频</p>
<ul>
<li>MySQL引擎</li>
<li>InnoDB底层原理</li>
<li>索引</li>
<li>索引优化！</li>
</ul>
<h2 id="12、动态-SQL"><a href="#12、动态-SQL" class="headerlink" title="12、动态 SQL"></a>12、动态 SQL</h2><p>&#x3D;&#x3D;<strong>什么是动态SQL：动态SQL就是指根据不同条件生成的SQL语句</strong>&#x3D;&#x3D;</p>
<p>利用动态SQL这一特性可以彻底摆脱这种痛苦。</p>
<pre><code class="xml">动态 SQL元素和  JSTL 或任何基于类 XML 语言的文本处理器相似。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。

if
choose (when, otherwise)
trim (where, set)
foreach
</code></pre>
<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><pre><code class="sql">CREATE TABLE `blog`(
    `id` VARCHAR(50) NOT NULL COMMENT &#39;博客id&#39;,
    `title` VARCHAR(100) NOT NULL COMMENT &#39;博客标题&#39;,
    `author` VARCHAR(30) NOT NULL COMMENT &#39;博客作者&#39;,
    `create_time` datetime NOT NULL COMMENT &#39;创建时间&#39;,
    `views` INT(30) NOT NULL COMMENT &#39;浏览量&#39;
    )ENGINE = INNODB DEFAULT charset=utf8
</code></pre>
<p>创建一个基础工程</p>
<ol>
<li><p>导包</p>
</li>
<li><p>编写配置文件</p>
</li>
<li><p>编写实体类</p>
<pre><code class="java">
@Data
public class Bloginfo &#123;
    private int id;
    private String title;
    private String author;
    private Date createTime;
    private int views;
&#125;
</code></pre>
</li>
<li><p>编写实体类对应Mapper接口 和 Mapper.XML文件</p>
<p>自动提交事务【工具类】</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220710224107966.png" alt="image-20220710224107966"></p>
</li>
</ol>
<h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><pre><code class="xml">  &lt;select id=&quot;querBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;Bloginfo&quot;&gt;
        select * from blog where 1 = 1
        &lt;if test=&quot;title != null&quot;&gt;
            and title = #&#123;title&#125;
        &lt;/if&gt;
        &lt;if test=&quot;author != null&quot;&gt;
            and author = #&#123;author&#125;
        &lt;/if&gt;
    &lt;/select&gt;
</code></pre>
<h3 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose (when, otherwise)"></a>choose (when, otherwise)</h3><pre><code class="xml">&lt;select id=&quot;querBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;Bloginfo&quot;&gt;
        select * from blog
        &lt;where&gt;
            &lt;choose&gt;
                &lt;when test=&quot;title != null&quot;&gt;
                    title = #&#123;title&#125;
                &lt;/when&gt;
                &lt;when test=&quot;author != null&quot;&gt;
                    and author = #&#123;author&#125;
                &lt;/when&gt;
                &lt;otherwise&gt;
                    and views = #&#123;views&#125;
                &lt;/otherwise&gt;
            &lt;/choose&gt;
        &lt;/where&gt;

    &lt;/select&gt;
</code></pre>
<h3 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim (where, set)"></a>trim (where, set)</h3><pre><code class="xml">&lt;select id=&quot;querBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;Bloginfo&quot;&gt;
        select * from blog
        &lt;where&gt;
            &lt;if test=&quot;title != null&quot;&gt;
                title = #&#123;title&#125;
            &lt;/if&gt;
            &lt;if test=&quot;author != null&quot;&gt;
                and author = #&#123;author&#125;
            &lt;/if&gt;
        &lt;/where&gt;

    &lt;/select&gt;
</code></pre>
<pre><code class="xml">&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;
  update Author
    &lt;set&gt;
      &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt;
      &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt;
      &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt;
      &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt;
    &lt;/set&gt;
  where id=#&#123;id&#125;
&lt;/update&gt;
</code></pre>
<p>&#x3D;&#x3D;<strong>所谓的动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码</strong>&#x3D;&#x3D;</p>
<h3 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h3><p>有的时候，我们可能会将一些功能的部分抽取出来，方便复用！</p>
<ol>
<li><p>使用SQL标签抽取公共的部分</p>
<pre><code class="xml">&lt;sql id=&quot;if-title-aothor&quot;&gt;
        &lt;if test=&quot;title != null&quot;&gt;
            and title = #&#123;title&#125;
        &lt;/if&gt;
        &lt;if test=&quot;author != null&quot;&gt;
            and author = #&#123;author&#125;
        &lt;/if&gt;
    &lt;/sql&gt;
</code></pre>
</li>
<li><p>在需要使用的地方使用<code>include</code>标签引用即可</p>
<pre><code class="xml">&lt;select id=&quot;querBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;Bloginfo&quot;&gt;
        select * from blog 
        &lt;where&gt;
            &lt;include refid=&quot;if-title-aothor&quot;/&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<p>注意事项：</p>
<ul>
<li>最好基于单表来定义SQL片段！</li>
<li>不要存在where标签</li>
</ul>
</li>
</ol>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><pre><code class="xml">select * from user where 1 = 1 and 

&lt;foreach item=&quot;id&quot; collection=&quot;ids&quot;
      open=&quot;(&quot; separator=&quot;or&quot; close=&quot;)&quot;&gt;
        #&#123;id&#125;
  &lt;/foreach&gt;

(id = 1 or id = 2 or id = 3)
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220711223613391.png" alt="image-20220711223613391"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220711224134688.png" alt="image-20220711224134688"></p>
<pre><code class="xml">   &lt;!--
         select * from user where 1 = 1 and (id = 1 or id = 2 or id = 3)

         我们现在传递一个万能的map，这map中可以存在一个集合！
    --&gt;
    &lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;Bloginfo&quot;&gt;
        select * from blog
        &lt;where&gt;
            &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;
               id = #&#123;id&#125;
            &lt;/foreach&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<p>&#x3D;&#x3D;动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了!&#x3D;&#x3D;</p>
<p>建议：</p>
<ul>
<li>先在MySQL中写出完整的SQL，再对应的去修改成为我们的动态SQL实现通用即可！</li>
</ul>
<h2 id="13、缓存"><a href="#13、缓存" class="headerlink" title="13、缓存"></a>13、缓存</h2><h3 id="13-1、简介"><a href="#13-1、简介" class="headerlink" title="13.1、简介"></a>13.1、简介</h3><pre><code>查询	：	连接数据库 ，耗资源！
    一次查询的结果，给他暂存在一个可以直接取到的地方！---&gt;内存·：缓存
    
我们再次查询相同数据的时候，直接走缓存，就不用走数据库了
</code></pre>
<ol>
<li>什么是缓存 [ Cache ]?<ul>
<li>存在内存中的临时数据。</li>
<li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库数据文件）查询，从缓存中查询；从而提高查询效率，解决了高并发系统的性能问题。</li>
</ul>
</li>
<li>为什么使用缓存？<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li>
</ul>
</li>
<li>什么样的数据能使用缓存？<ul>
<li>经常查询并且不经常改变的数据。</li>
</ul>
</li>
</ol>
<h3 id="13-2、MyBatis缓存"><a href="#13-2、MyBatis缓存" class="headerlink" title="13.2、MyBatis缓存"></a>13.2、MyBatis缓存</h3><ul>
<li>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存，缓存可以极的提升查询效率。</li>
<li>MyBatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong><ul>
<li>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）</li>
<li>二级缓存需要手动开启和配置，它是基于namespace级别的缓存。</li>
<li>为了提高扩展性，MyBatis定义了缓存接口<code>Cache</code>。我们可以通过实习<code>Cache</code>接口来自定义二级缓存</li>
</ul>
</li>
</ul>
<h3 id="13-3、一级缓存"><a href="#13-3、一级缓存" class="headerlink" title="13.3、一级缓存"></a>13.3、一级缓存</h3><ul>
<li>一级缓存也叫本地缓存：<ul>
<li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li>
<li>以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库；</li>
</ul>
</li>
</ul>
<p>测试步骤：</p>
<ol>
<li><p>开启日志！</p>
</li>
<li><p>测试在一个Session中查询两次相同的记录</p>
</li>
<li><p>查看日志输出<img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220713203648834.png" alt="image-20220713203648834"></p>
<p>缓存失效的情况：</p>
<ol>
<li><p>查询不同的东西</p>
</li>
<li><p>增删改操作，可能会改变原来的数据，所以必定会刷新缓存！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220713204706301.png" alt="image-20220713204706301"></p>
</li>
<li><p>查询不同的Mapper.xml</p>
</li>
<li><p>手动清除缓存！<img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220713204903410.png" alt="image-20220713204903410"></p>
</li>
</ol>
</li>
</ol>
<p>小结：一级缓存默认市开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！</p>
<p>一级缓存就是一个Map。</p>
<h3 id="13-4、二级缓存"><a href="#13-4、二级缓存" class="headerlink" title="13.4、二级缓存"></a>13.4、二级缓存</h3><ul>
<li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li>
<li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</li>
<li>工作机制<ul>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li>
<li>新的会话查询信息，就可以从二级缓存中获取内容；</li>
<li>不同的mapper查处的数据会放在自己对应的缓存（map）中；</li>
</ul>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>开启全局缓存</p>
<pre><code class="xml">        &lt;!--显示的开启全局缓存--&gt;
        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
</code></pre>
</li>
<li><p>在要使用二级缓存的Mapper中开启</p>
<pre><code class="xml">    &lt;!--在当前Mapper.xml中使用二级缓存--&gt;
    &lt;cache/&gt;
</code></pre>
<p>也可以自定义参数</p>
<pre><code class="xml">    &lt;!--在当前Mapper.xml中使用二级缓存--&gt;
    &lt;cache eviction=&quot;FIFO&quot;
           flushInterval=&quot;60000&quot;
           size=&quot;512&quot;
           readOnly=&quot;true&quot;/&gt;
</code></pre>
</li>
<li><p>测试：</p>
<ol>
<li><p>问题：我们需要将实体类序列化！否者就会报错！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220713211107966.png" alt="image-20220713211107966"></p>
</li>
</ol>
</li>
</ol>
<p>小结：</p>
<ul>
<li>只要开启了二级缓存，在同一个Mapper下就有效</li>
<li>所有的数据都会先放在一级缓存中；</li>
<li>只有当会话提交，或者关闭的时候，才会提交到二级缓存中！</li>
</ul>
<h3 id="13-5、缓存原理"><a href="#13-5、缓存原理" class="headerlink" title="13.5、缓存原理"></a>13.5、缓存原理</h3><p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/image-20220713212611022.png" alt="image-20220713212611022"></p>
<h3 id="13-6、自定义缓存-ehcache"><a href="#13-6、自定义缓存-ehcache" class="headerlink" title="13.6、自定义缓存-ehcache"></a>13.6、自定义缓存-ehcache</h3><pre><code>Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存
</code></pre>
<p>要在程序中使用ehcache，先要导包！</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
    &lt;version&gt;1.2.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>在mapper中指定使用我们的ehcache缓存实现！</p>
<p>ehcache.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;
         updateCheck=&quot;false&quot;&gt;
    &lt;!--
        diskStore:为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下:
        user.home - 用户主目录
        user.dir  - 用户当前工作目录
        Java.io.tmpdir - 默认临时文件路径
    --&gt;
    &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt;

    &lt;defaultCache
        eternal=&quot;false&quot;
        maxElementsInMemory=&quot;10000&quot;
        overflowToDisk=&quot;false&quot;
        diskPersistent=&quot;false&quot;
        timeToIdleSeconds=&quot;1800&quot;
        timeToLiveSeconds=&quot;259200&quot;
        memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;

    &lt;cache
            name=&quot;cloud_user&quot;
            eternal=&quot;false&quot;
            maxElementsInMemory=&quot;5000&quot;
            overflowToDisk=&quot;false&quot;
            diskPersistent=&quot;false&quot;
            timeToIdleSeconds=&quot;1800&quot;
            timeToLiveSeconds=&quot;1800&quot;
            memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;
    &lt;!--
        defaultCache:默认缓存策略，当cache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。
    --&gt;
    &lt;!--
        name:缓存名称
        maxElementsInMemory:缓存最大数目
        maxElementsOnDisk:硬盘最大缓存个数
        eternal:对象是否永久有效，一但设置了timeout将不起作用
        overflowToDisk:是否保存到磁盘，当系统宕机时
        timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
        timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷
        diskPersistent:是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
        diskSpoolBufferSizeMB:这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
        diskExpiryThreadIntervalSeconds:磁盘失效线程运行时间间隔，默认是120秒。
        memoryStoreEvictionPolicy:当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
        clearOnFlush:内存数量最大时是否清除。
        memoryStoreEvictionPolicy:可选策略有:LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。
        FIFO，first in first out，这个是大家最熟的，先进先出。
        LFU，Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清除缓存。
        LRU，Least Recently Used，最近最少使用，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清除缓存。
    --&gt;

    
&lt;/ehcache&gt;
</code></pre>
<p>Redis数据库来做缓存！</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #ff7d73">
                SSM
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/MyBatis/" style="color: #00bcd4">
                MyBatis
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/mybatis_狂神说/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/18/SpringMVC_狂神说/">
        <h2 class="post-title">SpringMVC_狂神说</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/SSM/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                SSM
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>ssm: mybatis + Spring + SpringMVC MVC三层架构</p>
<p>JavaSE:认真学习, 老师带，入门快<br>JavaWeb:认真学习,老师带,入门快<br>SSM框架:研究官方文档，锻炼自学能力，锻炼笔记能力，锻炼项目能力</p>
<p>SpringMVC + Vue + SpringBoot + SpringCloud + Linux</p>
<p>SSM &#x3D; JavaWeb做项目;</p>
<p>Spring: IOC和APO</p>
<p>SpringMVC: SpringMVC的执行流程!</p>
<p>SpringMVC : SSM框架整合!</p>
<p>Spring</p>
<p>MVC:模型(dao, service) 视图 (jsp)控制器 (Servlet)<br>dao<br>service<br>servlet :转发，重定向<br>jsp&#x2F;html</p>
<p>前端数据传输实体类</p>
<p>实体类:用户名，密码，生日，爱好，… 20个</p>
<p>前端:用户名密码</p>
<p>pojo: User<br>vo: UserVo<br>dto:</p>
<p><strong>JSP:本质就是一个Servlet</strong></p>
<p>假设:你的项目的架构，是设计好的，还是演进的?</p>
<ul>
<li>Alibaba PHP</li>
<li>随着用户大， Java</li>
<li>王坚去 IOE MySQL</li>
<li>MySQL : MySQL–&gt; AliSQL. AliRedis</li>
<li>Allinone –微服务</li>
</ul>
<p>MVC :</p>
<p>MWM: M V VM ViewModel :双向绑定</p>
<h2 id="1、什么是MVC"><a href="#1、什么是MVC" class="headerlink" title="1、什么是MVC"></a>1、什么是MVC</h2><ul>
<li>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。</li>
<li>是将业务逻辑、数据、显示分离的方法来组织代码。</li>
<li>MVC主要作用是<strong>降低了视图与业务逻辑间的双向偶合</strong>。</li>
<li>MVC不是一种设计模式，<strong>MVC是一种架构模式</strong>。当然不同的MVC存在差异。</li>
</ul>
<p><strong>Model（模型）：</strong>数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p>
<p><strong>View（视图）：</strong>负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p>
<p><strong>Controller（控制器）：</strong>接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。</p>
<p><strong>最典型的MVC就是JSP + servlet + javabean的模式。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331221325100-1165356814.png" alt="img"></p>
<h3 id="1-1、Model1时代"><a href="#1-1、Model1时代" class="headerlink" title="1.1、Model1时代"></a>1.1、Model1时代</h3><ul>
<li>在web早期的开发中，通常采用的都是Model1。</li>
<li>Model1中，主要分为两层，视图层和模型层。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331221347503-978638377.png" alt="img"></p>
<p>Model1优点：架构简单，比较适合小型项目开发；</p>
<p>Model1缺点：JSP职责不单一，职责过重，不便于维护；</p>
<h3 id="1-2、Model2时代"><a href="#1-2、Model2时代" class="headerlink" title="1.2、Model2时代"></a>1.2、Model2时代</h3><p>Model2把一个项目分成三部分，包括<strong>视图、控制、模型。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331221406483-639584230.png" alt="img"></p>
<p>用户发请求</p>
<ol>
<li>Servlet接收请求数据，并调用对应的业务逻辑方法</li>
<li>业务处理完毕，返回更新后的数据给servlet</li>
<li>servlet转向到JSP，由JSP来渲染页面</li>
<li>响应给前端更新后的页面</li>
</ol>
<p><strong>职责分析：</strong></p>
<p><strong>Controller：控制器</strong></p>
<ol>
<li>取得表单数据</li>
<li>调用业务逻辑</li>
<li>转向指定的页面</li>
</ol>
<p><strong>Model：模型</strong></p>
<ol>
<li>业务逻辑</li>
<li>保存数据的状态</li>
</ol>
<p><strong>View：视图</strong></p>
<ol>
<li>显示页面</li>
</ol>
<p>Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。</p>
<h3 id="1-3、回顾Servlet"><a href="#1-3、回顾Servlet" class="headerlink" title="1.3、回顾Servlet"></a>1.3、回顾Servlet</h3><ol>
<li><p>新建一个Maven工程当做父工程！ pom依赖！</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.12&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;version&gt;2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
        &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
        &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;version&gt;1.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
</li>
<li><p>建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！</p>
</li>
<li><p>导入servlet 和 jsp 的 jar 依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
    &lt;version&gt;2.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
    &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
    &lt;version&gt;2.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>编写一个Servlet类，用来处理用户的请求</p>
<pre><code class="java">package com.kuang.servlet;

//实现Servlet接口
public class HelloServlet extends HttpServlet &#123;
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        //取得参数
        String method = req.getParameter(&quot;method&quot;);
        if (method.equals(&quot;add&quot;))&#123;
            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;);
        &#125;
        if (method.equals(&quot;delete&quot;))&#123;
            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;);
        &#125;
        //业务逻辑
        //视图跳转
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/hello.jsp&quot;).forward(req,resp);
    &#125;

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        doGet(req,resp);
    &#125;
&#125;
</code></pre>
</li>
<li><p>编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Kuangshen&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    $&#123;msg&#125;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>在web.xml中注册Servlet</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/user&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
</li>
<li><p>配置Tomcat，并启动测试</p>
<ul>
<li>localhost:8080&#x2F;user?method&#x3D;add</li>
<li>localhost:8080&#x2F;user?method&#x3D;delete</li>
</ul>
</li>
<li><p>访问结果</p>
<p><img src="/assets/SpringMVC_%E7%8B%82%E7%A5%9E%E8%AF%B4/1905053-20200331212910583-2051430940.png" alt="img"></p>
</li>
</ol>
<p><strong>MVC框架要做哪些事情</strong></p>
<ol>
<li>将url映射到java类或java类的方法 .</li>
<li>封装用户提交的数据 .</li>
<li>处理请求–调用相关的业务处理–封装响应数据 .</li>
<li>将响应的数据进行渲染 . jsp &#x2F; html 等表示层数据 .</li>
</ol>
<p><strong>说明：</strong></p>
<p>常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等….</p>
<h2 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331222018441-1850931217.png" alt="img"></p>
<p>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。</p>
<p>查看官方文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web">https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web</a></p>
<p><strong>我们为什么要学习SpringMVC呢?</strong></p>
<p>Spring MVC的特点：</p>
<ol>
<li>轻量级，简单易学</li>
<li>高效 , 基于请求响应的MVC框架</li>
<li>与Spring兼容性好，无缝结合</li>
<li>约定优于配置</li>
<li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li>
<li>简洁灵活</li>
</ol>
<p>Spring的web框架围绕<strong>DispatcherServlet</strong> [ 调度Servlet ] 设计。</p>
<p>DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；</p>
<p>正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 .</p>
<p><strong>最重要的一点还是用的人多 , 使用的公司多 .</strong></p>
<h3 id="中心控制器"><a href="#中心控制器" class="headerlink" title="中心控制器"></a>中心控制器</h3><p>Spring的web框架围绕DispatcherServlet设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。</p>
<p>Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动</strong> , <strong>围绕一个中心Servlet分派请求及提供其他功能</strong>，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331222037711-828417064.png" alt="img"></p>
<p>SpringMVC的原理如下图所示：</p>
<p>当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331222109176-906298972.png" alt="img"></p>
<h3 id="SpringMVC执行原理"><a href="#SpringMVC执行原理" class="headerlink" title="SpringMVC执行原理"></a>SpringMVC执行原理</h3><p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331222126131-219513987-165823762951013.png" alt="1905053-20200331222126131-219513987"></p>
<p>图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p>
<p><strong>简要分析执行流程</strong></p>
<ol>
<li>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。<ul>
<li>我们假设请求的url为 : <a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a>:8080&#x2F;SpringMVC&#x2F;hello</li>
<li><strong>如上url拆分成三部分：</strong></li>
<li><a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a>:8080服务器域名</li>
<li>SpringMVC部署在服务器上的web站点</li>
<li>hello表示控制器</li>
<li>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</li>
</ul>
</li>
<li>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</li>
<li>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</li>
<li>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</li>
<li>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</li>
<li>Handler让具体的Controller执行。</li>
<li>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</li>
<li>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</li>
<li>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</li>
<li>视图解析器将解析的逻辑视图名传给DispatcherServlet。</li>
<li>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</li>
<li>最终视图呈现给用户。</li>
</ol>
<p>在这里先听一遍原理，不理解没有关系，我们马上来写一个对应的代码实现大家就明白了，如果不明白，那就写10遍，没有笨人，只有懒人！</p>
<h2 id="3、HelloSpringMVC-配置版"><a href="#3、HelloSpringMVC-配置版" class="headerlink" title="3、HelloSpringMVC(配置版)"></a>3、HelloSpringMVC(配置版)</h2><ol>
<li><p>新建一个Moudle ， 添加web的支持！</p>
</li>
<li><p>确定导入了SpringMVC 的依赖！</p>
</li>
<li><p>配置web.xml ， 注册DispatcherServlet</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--1.注册DispatcherServlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!--启动级别-1--&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;
    &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
</li>
<li><p>编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml说明，这里的名称要求是按照官方来的</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
</li>
<li><p>添加 处理映射器</p>
<pre><code class="xml">&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
</code></pre>
</li>
<li><p>添加 处理器适配器</p>
<pre><code class="xml">&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;
</code></pre>
</li>
<li><p>添加 视图解析器</p>
<pre><code class="xml">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;
    &lt;!--前缀--&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
    &lt;!--后缀--&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li><p>编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；</p>
<pre><code class="java">package com.kuang.controller;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

//注意：这里我们先导入Controller接口
public class HelloController implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
        //ModelAndView 模型和视图
        ModelAndView mv = new ModelAndView();

        //封装对象，放在ModelAndView中。Model
        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC1!，我是成博&quot;);
        //封装要跳转的视图，放在ModelAndView中
        mv.setViewName(&quot;hello&quot;); //: /WEB-INF/jsp/hello.jsp
        return mv;
    &#125;
    
&#125;
</code></pre>
</li>
<li><p>将自己的类交给SpringIOC容器，注册bean</p>
<pre><code class="xml">&lt;!--Handler--&gt;
&lt;bean id=&quot;/hello&quot; class=&quot;com.kuang.controller.HelloController&quot;/&gt;
</code></pre>
</li>
<li><p>写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Kuangshen&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    $&#123;msg&#125;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>配置Tomcat 启动测试！</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331222531691-1302265141.png" alt="img"></p>
<p><strong>可能遇到的问题：访问出现404，排查步骤：</strong></p>
<ol>
<li><p>查看控制台输出，看一下是不是缺少了什么jar包。</p>
</li>
<li><p>如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！（与classes同级目录）</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331212956858-1274463802.png" alt="img"></p>
</li>
<li><p>重启Tomcat 即可解决！</p>
</li>
</ol>
<p>小结：看这个估计大部分同学都能理解其中的原理了，但是我们实际开发才不会这么写，不然就疯了，还学这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331223102129-1564021137.png" alt="img"></p>
<h2 id="4、使用注解开发SpringMVC（注解版）"><a href="#4、使用注解开发SpringMVC（注解版）" class="headerlink" title="4、使用注解开发SpringMVC（注解版）"></a>4、使用注解开发SpringMVC（注解版）</h2><p><strong>第一步:新建一个Moudle , 添加web支持！</strong>建立包结构 com.kuang.controller</p>
<p><strong>第二步:由于Maven可能存在资源过滤的问题，我们将配置完善</strong></p>
<pre><code class="xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<p><strong>第三步:在pom.xml文件引入相关的依赖</strong>：<br>主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！</p>
<p><strong>第四步:配置web.xml</strong></p>
<p>注意点：</p>
<ul>
<li><p>注意web.xml版本问题，要最新版！</p>
</li>
<li><p>注册DispatcherServlet</p>
</li>
<li><p>关联SpringMVC的配置文件</p>
</li>
<li><p>启动级别为1</p>
</li>
<li><p>映射路径为 &#x2F; 【不要用&#x2F;*，会404】</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--1.注册servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!--所有请求都会被springmvc拦截 --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<pre><code class="java">/ 和 /* 的区别：
&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；
即：.jsp 不会进入spring的 DispatcherServlet类 。
&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，
会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。
</code></pre>
</li>
</ul>
<p><strong>第五步:添加Spring MVC配置文件</strong></p>
<ul>
<li>让IOC的注解生效</li>
<li>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …..</li>
<li>MVC的注解驱动</li>
<li>配置视图解析器</li>
</ul>
<p>在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;
    &lt;!-- 让Spring MVC不处理静态资源 过滤掉一些静态资源，如.css  .js  .html .mp3--&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;!--
    支持mvc注解驱动
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想使@RequestMapping注解生效
        必须向上下文中注册DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
     --&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>在视图解析器中我们把所有的视图都存放在&#x2F;WEB-INF&#x2F;目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。</p>
<p><strong>第六步:创建Controller</strong></p>
<p>编写一个Java控制类： com.kuang.controller.HelloController , 注意编码规范</p>
<pre><code class="java">package com.kuang.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping(&quot;/HelloController&quot;)//多添加一级访问
public class HelloController &#123;

    //真实访问地址 : 项目名/HelloController/hello
    @RequestMapping(&quot;/hello&quot;)//请求路径
    public String sayHello(Model model) &#123;
        //向模型中添加属性msg与值，可以在JSP页面中取出并渲染
        model.addAttribute(&quot;msg&quot;, &quot;hello,SpringMVC，我是成博&quot;);
        //会被视图解析器处理，web-inf/jsp/hello.jsp
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<ul>
<li>@Controller是为了让Spring IOC容器初始化时自动扫描到；</li>
<li>@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是&#x2F;HelloController&#x2F;hello；</li>
<li>方法中声明Model类型的参数是为了把Action中的数据带到视图中；</li>
<li>方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF&#x2F;jsp&#x2F;<strong>hello</strong>.jsp。</li>
</ul>
<p><strong>第七步:创建视图层</strong></p>
<p>在WEB-INF&#x2F; jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；</p>
<p>可以通过EL表示取出Model中存放的值，或者对象；</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;SpringMVC&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    $&#123;msg&#125;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>第八步:配置Tomcat运行</strong></p>
<p>配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331213100620-1365283722.png" alt="img"></p>
<p><strong>OK，运行成功！</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>实现步骤其实非常的简单：</p>
<ol>
<li>新建一个web项目</li>
<li>导入相关jar包</li>
<li>编写web.xml , 注册DispatcherServlet</li>
<li>编写springmvc配置文件</li>
<li>接下来就是去创建对应的控制类 , controller</li>
<li>最后完善前端视图和controller之间的对应</li>
<li>测试运行调试.</li>
</ol>
<p>使用springMVC必须配置的三大件：</p>
<p><strong>处理器映射器、处理器适配器、视图解析器</strong></p>
<p>通常，我们只需要<strong>手动配置视图解析器</strong>，而<strong>处理器映射器</strong>和<strong>处理器适配器</strong>只需要开启<strong>注解驱动</strong>即可，而省去了大段的xml配置</p>
<h2 id="5、Controller-及-RestFul风格"><a href="#5、Controller-及-RestFul风格" class="headerlink" title="5、Controller 及 RestFul风格"></a>5、Controller 及 RestFul风格</h2><h3 id="控制器Controller"><a href="#控制器Controller" class="headerlink" title="控制器Controller"></a>控制器Controller</h3><ul>
<li>控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</li>
<li>控制器负责解析用户的请求并将其转换为一个模型。</li>
<li>在Spring MVC中一个控制器类可以包含多个方法</li>
<li>在Spring MVC中，对于Controller的配置方式有很多种</li>
</ul>
<p>我们来看看有哪些方式可以实现：</p>
<h3 id="实现Controller接口"><a href="#实现Controller接口" class="headerlink" title="实现Controller接口"></a>实现Controller接口</h3><p>Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；</p>
<pre><code class="java">//实现该接口的类获得控制器功能
public interface Controller &#123;
    //处理请求且返回一个模型与视图对象
    ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;
&#125;
</code></pre>
<p><strong>测试</strong></p>
<ol>
<li><p>新建一个Moudle，springmvc-04-controller 。 将刚才的03 拷贝一份, 我们进行操作！</p>
<ul>
<li>删掉HelloController</li>
<li>mvc的配置文件只留下 视图解析器！</li>
</ul>
</li>
<li><p>编写一个Controller类，ControllerTest1</p>
<pre><code class="java">//定义控制器
//注意点：不要导错包，实现Controller接口，重写方法；
public class ControllerTest1 implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        //返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
</li>
<li><p>编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类</p>
<pre><code class="xml">&lt;bean name=&quot;/t1&quot; class=&quot;com.kuang.controller.ControllerTest1&quot;/&gt;
</code></pre>
</li>
<li><p>编写前端test.jsp，注意在WEB-INF&#x2F;jsp目录下编写，对应我们的视图解析器</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Kuangshen&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    $&#123;msg&#125;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 &#x2F; ，所以请求不用加项目名，OK！</p>
</li>
</ol>
<p><img src="/assets/SpringMVC_%E7%8B%82%E7%A5%9E%E8%AF%B4/1905053-20200331213134363-472773058.png" alt="img"></p>
<p><strong>说明：</strong></p>
<ul>
<li>实现接口Controller定义控制器是较老的办法</li>
<li>缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；</li>
</ul>
<h3 id="使用注解-Controller"><a href="#使用注解-Controller" class="headerlink" title="使用注解@Controller"></a>使用注解@Controller</h3><ul>
<li><p>@Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；</p>
</li>
<li><p>Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</p>
<pre><code class="xml">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
&lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;
</code></pre>
</li>
<li><p>增加一个ControllerTest2类，使用注解实现；</p>
<pre><code class="java">//@Controller注解的类会自动添加到Spring上下文中
//代表这个类会被Spring按管
//被这个注解的类，中的所有方法，如果返回值是String，并且有具体页面可以跳转，那么就会被视图解析器解析;
@Controller
public class ControllerTest2&#123;

    //映射访问路径
    @RequestMapping(&quot;/t2&quot;)
    public String index(Model model)&#123;
        //Spring MVC会自动实例化一个Model对象用于向视图中传值
        model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;);
        //返回视图位置
        return &quot;test&quot;;
    &#125;

&#125;
</code></pre>
</li>
<li><p>运行tomcat测试</p>
</li>
</ul>
<p><img src="/assets/SpringMVC_%E7%8B%82%E7%A5%9E%E8%AF%B4/1905053-20200331213150942-1828421815.png" alt="img"></p>
<p><strong>可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。</strong></p>
<p>注解方式是平时使用的最多的方式！除了这两种之外还有其他的方式，大家想要自己研究的话，可以参考我的博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hellokuangshen/p/11270742.html">https://www.cnblogs.com/hellokuangshen/p/11270742.html</a></p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h3><p><strong>@RequestMapping</strong></p>
<ul>
<li><p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
</li>
<li><p>为了测试结论更加准确，我们可以加上一个项目名测试 myweb</p>
</li>
<li><p>只注解在方法上面</p>
<pre><code class="java">@Controller
public class TestController &#123;
    @RequestMapping(&quot;/h1&quot;)
    public String test()&#123;
        return &quot;test&quot;;
    &#125;
&#125;
</code></pre>
<p>访问路径：<a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a>:8080 &#x2F; 项目名 &#x2F; h1</p>
</li>
<li><p>同时注解类与方法</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/admin&quot;)
public class TestController &#123;
    @RequestMapping(&quot;/h1&quot;)
    public String test()&#123;
        return &quot;test&quot;;
    &#125;
&#125;
</code></pre>
<p>访问路径：<a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a>:8080 &#x2F; 项目名&#x2F; admin &#x2F;h1 , 需要先指定类的路径再指定方法的路径；</p>
</li>
</ul>
<h2 id="6、RestFul-风格-简洁，高效，安全"><a href="#6、RestFul-风格-简洁，高效，安全" class="headerlink" title="6、RestFul 风格(简洁，高效，安全)"></a>6、RestFul 风格(简洁，高效，安全)</h2><p><strong>概念</strong></p>
<p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p><strong>功能</strong></p>
<ul>
<li>资源：互联网所有的事物都可以被抽象为资源</li>
<li>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</li>
<li>分别对应 添加、 删除、修改、查询。</li>
</ul>
<p><strong>传统方式操作资源</strong> ：通过不同的参数来实现不同的效果！方法单一，post 和 get</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</li>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</li>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</li>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</li>
</ul>
<p><strong>使用RESTful操作资源</strong> ： 可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</li>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</li>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</li>
<li><a target="_blank" rel="noopener" href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</li>
</ul>
<p><strong>学习测试</strong></p>
<ol>
<li><p>在新建一个类 RestFulController</p>
<pre><code class="java">@Controller
public class RestFulController &#123;
&#125;
</code></pre>
</li>
<li><p>在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p>
<pre><code class="java">@Controller
public class RestFulController &#123;
    //原来的 :  http://localhost: 8080/add?a=1&amp;b=2
    //RestFul :  http://localhost : 8080/add/1/2
    
    //映射访问路径
    @RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)
    public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123;
        
        int result = p1+p2;
        //Spring MVC会自动实例化一个Model对象用于向视图中传值
        model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);
        //返回视图位置
        return &quot;test&quot;;
        
    &#125;
    
&#125;
</code></pre>
</li>
<li><p>我们来测试请求查看下<br><img src="/assets/SpringMVC_%E7%8B%82%E7%A5%9E%E8%AF%B4/1905053-20200331213217087-619232504.png" alt="img"></p>
</li>
<li><p>思考：使用路径变量的好处？</p>
<ul>
<li>使路径变得更加简洁；</li>
<li>获得参数更加方便，框架会自动进行类型转换。</li>
<li>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是&#x2F;commit&#x2F;1&#x2F;a，则路径与方法不匹配，而不会是参数转换失败。</li>
</ul>
<p><img src="/assets/SpringMVC_%E7%8B%82%E7%A5%9E%E8%AF%B4/1905053-20200401214609681-1237588624.png" alt="img"></p>
</li>
<li><p>我们来修改下对应的参数类型，再次测试</p>
<pre><code class="java">//映射访问路径
@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)
public String index(@PathVariable int p1, @PathVariable String p2, Model model)&#123;

    String result = p1+p2;
    //Spring MVC会自动实例化一个Model对象用于向视图中传值
    model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);
    //返回视图位置
    return &quot;test&quot;;

&#125;
</code></pre>
<p><img src="/assets/SpringMVC_%E7%8B%82%E7%A5%9E%E8%AF%B4/1905053-20200401214657561-1298821776.png" alt="img"></p>
</li>
</ol>
<p><strong>使用method属性指定请求类型</strong></p>
<p>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等</p>
<p>我们来测试一下：</p>
<ul>
<li><p>增加一个方法</p>
<pre><code class="java">//映射访问路径,必须是POST请求
@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.POST&#125;)
public String index2(Model model)&#123;
    model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;);
    return &quot;test&quot;;
&#125;
</code></pre>
</li>
<li><p>我们使用浏览器地址栏进行访问默认是Get请求，会报错405：<br><img src="/assets/SpringMVC_%E7%8B%82%E7%A5%9E%E8%AF%B4/1905053-20200401214714976-802588010.png" alt="img"></p>
</li>
<li><p>如果将POST修改为GET则正常了；</p>
<pre><code class="java">//映射访问路径,必须是Get请求
@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.GET&#125;)
public String index2(Model model)&#123;
    model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;);
    return &quot;test&quot;;
&#125;
</code></pre>
<p><img src="/assets/SpringMVC_%E7%8B%82%E7%A5%9E%E8%AF%B4/1905053-20200401214737681-664600385.png" alt="img"></p>
</li>
</ul>
<p><strong>小结：</strong></p>
<p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p><strong>所有的地址栏请求默认都会是 HTTP GET 类型的。</strong></p>
<p>方法级别的注解变体有如下几个： 组合注解</p>
<pre><code class="java">@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping
</code></pre>
<p>@GetMapping 是一个组合注解</p>
<pre><code class="java">@Controller
public class RestFulController &#123;
    //原来的 :  http://localhost: 8080/add?a=1&amp;b=2
    //RestFul :  http://localhost : 8080/add/1/2

    //映射访问路径
    //@RequestMapping(value = &quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;,method = RequestMethod.GET)
    //@GetMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)
    @GetMapping(path = &quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)
    public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123;
        
        int result = p1+p2;
        //Spring MVC会自动实例化一个Model对象用于向视图中传值
        model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);
        //返回视图位置
        return &quot;test&quot;;  
    &#125;
    
&#125;
</code></pre>
<p><img src="/assets/SpringMVC_%E7%8B%82%E7%A5%9E%E8%AF%B4/1905053-20200331213251638-969968192.png" alt="img"></p>
<p>它所扮演的是 @RequestMapping(method &#x3D;RequestMethod.GET) 的一个快捷方式。</p>
<p>平时使用的会比较多！</p>
<h3 id="小黄鸭调试法"><a href="#小黄鸭调试法" class="headerlink" title="小黄鸭调试法"></a>小黄鸭调试法</h3><p>场景一：<em>我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。</em></p>
<p>场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。</p>
<p>其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。</p>
<p><img src="/assets/SpringMVC_%E7%8B%82%E7%A5%9E%E8%AF%B4/1905053-20200401214504256-745544113.png" alt="img"></p>
<p>此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。</p>
<h2 id="7、SpringMVC：结果跳转三种方式-转发、重定向"><a href="#7、SpringMVC：结果跳转三种方式-转发、重定向" class="headerlink" title="7、SpringMVC：结果跳转三种方式(转发、重定向)"></a>7、SpringMVC：结果跳转三种方式(转发、重定向)</h2><h3 id="7-1、ModelAndView"><a href="#7-1、ModelAndView" class="headerlink" title="7.1、ModelAndView"></a>7.1、ModelAndView</h3><p>设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .</p>
<p>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</p>
<pre><code class="xml">&lt;!-- 视图解析器 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
      id=&quot;internalResourceViewResolver&quot;&gt;
    &lt;!-- 前缀 --&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
    &lt;!-- 后缀 --&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p>对应的controller类</p>
<pre><code class="java">public class ControllerTest1 implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        //返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<h3 id="7-2、ServletAPI"><a href="#7-2、ServletAPI" class="headerlink" title="7.2、ServletAPI"></a>7.2、ServletAPI</h3><p>通过设置ServletAPI , 不需要视图解析器 .</p>
<ol>
<li>通过HttpServletResponse进行输出</li>
<li>通过HttpServletResponse实现重定向</li>
<li>通过HttpServletResponse实现转发</li>
</ol>
<pre><code class="java">@Controller
public class ResultGo &#123;

    @RequestMapping(&quot;/result/t1&quot;)
    public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
        rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;);
    &#125;

    @RequestMapping(&quot;/result/t2&quot;)
    public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;
        rsp.sendRedirect(&quot;/index.jsp&quot;);
    &#125;

    @RequestMapping(&quot;/result/t3&quot;)
    public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123;
        //转发
        req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;);
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp);
    &#125;

&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331213355173-975224060.png" alt="img"></p>
<h3 id="7-3、SpringMVC"><a href="#7-3、SpringMVC" class="headerlink" title="7.3、SpringMVC"></a>7.3、SpringMVC</h3><p><strong>通过SpringMVC来实现转发和重定向 - 无需视图解析器；</strong></p>
<p>测试前，需要将视图解析器注释掉</p>
<pre><code class="java">@Controller
public class ResultSpringMVC &#123;
    @RequestMapping(&quot;/rsm/t1&quot;)
    public String test1()&#123;
        //转发
        return &quot;/index.jsp&quot;;
    &#125;

    @RequestMapping(&quot;/rsm/t2&quot;)
    public String test2()&#123;
        //转发二
        return &quot;forward:/index.jsp&quot;;
    &#125;

    @RequestMapping(&quot;/rsm/t3&quot;)
    public String test3()&#123;
        //重定向
        return &quot;redirect:/index.jsp&quot;;
    &#125;
&#125;
</code></pre>
<p><strong>通过SpringMVC来实现转发和重定向 - 有视图解析器；</strong></p>
<p>重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.</p>
<p>可以重定向到另外一个请求实现 .</p>
<pre><code class="java">@Controller
public class ResultSpringMVC2 &#123;
    @RequestMapping(&quot;/rsm2/t1&quot;)
    public String test1()&#123;
        //转发
        return &quot;test&quot;;
    &#125;

    @RequestMapping(&quot;/rsm2/t2&quot;)
    public String test2()&#123;
        //重定向
        return &quot;redirect:/index.jsp&quot;;
        //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/
    &#125;

&#125;
</code></pre>
<h2 id="8、数据处理（接收请求参数及数据回显）"><a href="#8、数据处理（接收请求参数及数据回显）" class="headerlink" title="8、数据处理（接收请求参数及数据回显）"></a>8、数据处理（接收请求参数及数据回显）</h2><h3 id="处理提交数据"><a href="#处理提交数据" class="headerlink" title="处理提交数据"></a>处理提交数据</h3><p><strong>1、提交的域名称和处理方法的参数名一致</strong></p>
<p>提交数据 : <a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a>:8080&#x2F;hello?name&#x3D;kuangshen</p>
<p>处理方法 :</p>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<p>后台输出 : kuangshen</p>
<p><strong>2、提交的域名称和处理方法的参数名不一致</strong></p>
<p>提交数据 : <a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a>:8080&#x2F;hello?username&#x3D;kuangshen</p>
<p>处理方法 :</p>
<pre><code class="java">//@RequestParam(&quot;username&quot;) : username提交的域的名称 .
@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name)&#123;
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<p>后台输出 :</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331213420413-895694643.png" alt="img"></p>
<p><strong>3、提交的是一个对象</strong></p>
<p>要求提交的表单域和对象的属性名一致 , 参数使用对象即可</p>
<ol>
<li><p>实体类</p>
<pre><code class="Java">public class User &#123;
    private int id;
    private String name;
    private int age;
    //构造
    //get/set
    //tostring()
&#125;
</code></pre>
</li>
<li><p>提交数据 : <a target="_blank" rel="noopener" href="http://localhost:8080/user?name=kuangshen&amp;id=1&amp;age=15">http://localhost:8080/user?name=kuangshen&amp;id=1&amp;age=15</a></p>
</li>
<li><p>处理方法 :</p>
<pre><code class="java">@RequestMapping(&quot;/user&quot;)
public String user(User user)&#123;
    System.out.println(user);
    return &quot;hello&quot;;
&#125;
</code></pre>
<p>后台输出 : User { id&#x3D;1, name&#x3D;’kuangshen’, age&#x3D;15 }</p>
</li>
</ol>
<p><strong>说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。</strong></p>
<h3 id="数据显示到前端"><a href="#数据显示到前端" class="headerlink" title="数据显示到前端"></a>数据显示到前端</h3><p><strong>第一种 : 通过ModelAndView</strong></p>
<p>我们前面一直都是如此 . 就不过多解释</p>
<pre><code class="java">public class ControllerTest1 implements Controller &#123;

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;
        //返回一个模型视图对象
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);
        mv.setViewName(&quot;test&quot;);
        return mv;
    &#125;
&#125;
</code></pre>
<p><strong>第二种 : 通过ModelMap</strong></p>
<p>ModelMap</p>
<pre><code class="java">@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;name&quot;,name);
    System.out.println(name);
    return &quot;hello&quot;;
&#125;
</code></pre>
<p><strong>第三种 : 通过Model</strong></p>
<p>Model</p>
<pre><code class="java">@RequestMapping(&quot;/ct2/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;
    //封装要显示到视图中的数据
    //相当于req.setAttribute(&quot;name&quot;,name);
    model.addAttribute(&quot;msg&quot;,name);
    System.out.println(name);
    return &quot;test&quot;;
&#125;
</code></pre>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>就对于新手而言简单来说使用区别就是：</p>
<pre><code class="undefined">Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；

ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；

ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。
</code></pre>
<p>当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。</p>
<p><strong>请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。</strong></p>
<h2 id="9、数据处理（乱码问题）"><a href="#9、数据处理（乱码问题）" class="headerlink" title="9、数据处理（乱码问题）"></a>9、数据处理（乱码问题）</h2><p>测试步骤：</p>
<ol>
<li><p>我们可以在首页编写一个提交的表单</p>
<pre><code class="html">&lt;form action=&quot;/e/t&quot; method=&quot;post&quot;&gt;
  &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;
  &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
</li>
<li><p>后台编写对应的处理类</p>
<pre><code class="java">@Controller
public class Encoding &#123;
    @RequestMapping(&quot;/e/t&quot;)
    public String test(Model model,String name)&#123;
        model.addAttribute(&quot;msg&quot;,name); //获取表单提交的值
        return &quot;test&quot;; //跳转到test页面显示输入的值
    &#125;
&#125;
</code></pre>
</li>
<li><p>输入中文测试，发现乱码<br><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200402193540997-1854631524.png" alt="img"></p>
</li>
</ol>
<p>不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！</p>
<p>以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .</p>
<p>修改了xml文件需要重启服务器！</p>
<pre><code class="xml">&lt;!--2.配置SpringMVC的乱码过滤--&gt;
&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p>有些极端情况下.这个过滤器对get的支持不好 .</p>
<p>处理方法 :</p>
<ol>
<li><p>修改tomcat配置文件 ： 设置编码！</p>
<pre><code class="xml">&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot; /&gt;
</code></pre>
</li>
<li><p>自定义过滤器</p>
<pre><code class="java">package com.kuang.filter;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;

/**
 * 解决get和post请求 全部乱码的过滤器
 */
public class GenericEncodingFilter implements Filter &#123;

    @Override
    public void destroy() &#123;
    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
        //处理response的字符编码
        HttpServletResponse myResponse=(HttpServletResponse) response;
        myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);

        // 转型为与协议相关对象
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        // 对request包装增强
        HttpServletRequest myrequest = new MyRequest(httpServletRequest);
        chain.doFilter(myrequest, response);
    &#125;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
    &#125;

&#125;

//自定义request对象，HttpServletRequest的包装类
class MyRequest extends HttpServletRequestWrapper &#123;

    private HttpServletRequest request;
    //是否编码的标记
    private boolean hasEncode;
    //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰
    public MyRequest(HttpServletRequest request) &#123;
        super(request);// super必须写
        this.request = request;
    &#125;

    // 对需要增强方法 进行覆盖
    @Override
    public Map getParameterMap() &#123;
        // 先获得请求方式
        String method = request.getMethod();
        if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;
            // post请求
            try &#123;
                // 处理post乱码
                request.setCharacterEncoding(&quot;utf-8&quot;);
                return request.getParameterMap();
            &#125; catch (UnsupportedEncodingException e) &#123;
                e.printStackTrace();
            &#125;
        &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;
            // get请求
            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
            if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次
                for (String parameterName : parameterMap.keySet()) &#123;
                    String[] values = parameterMap.get(parameterName);
                    if (values != null) &#123;
                        for (int i = 0; i &lt; values.length; i++) &#123;
                            try &#123;
                                // 处理get乱码
                                values[i] = new String(values[i]
                                        .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);
                            &#125; catch (UnsupportedEncodingException e) &#123;
                                e.printStackTrace();
                            &#125;
                        &#125;
                    &#125;
                &#125;
                hasEncode = true;
            &#125;
            return parameterMap;
        &#125;
        return super.getParameterMap();
    &#125;

    //取一个值
    @Override
    public String getParameter(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        if (values == null) &#123;
            return null;
        &#125;
        return values[0]; // 取回参数的第一个值
    &#125;

    //取所有值
    @Override
    public String[] getParameterValues(String name) &#123;
        Map&lt;String, String[]&gt; parameterMap = getParameterMap();
        String[] values = parameterMap.get(name);
        return values;
    &#125;
&#125;
</code></pre>
</li>
</ol>
<p>这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！</p>
<p><strong>然后在web.xml中配置这个过滤器即可！</strong></p>
<p>乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！</p>
<h2 id="10、JSON讲解"><a href="#10、JSON讲解" class="headerlink" title="10、JSON讲解"></a>10、JSON讲解</h2><h3 id="什么是JSON？"><a href="#什么是JSON？" class="headerlink" title="什么是JSON？"></a>什么是JSON？</h3><ul>
<li>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。</li>
<li>采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据。</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
<p>在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p>
<ul>
<li>对象表示为键值对，数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<p><strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键&#x2F;值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：</p>
<pre><code class="json">&#123;&quot;name&quot;: &quot;QinJiang&quot;&#125;
&#123;&quot;age&quot;: &quot;3&quot;&#125;
&#123;&quot;sex&quot;: &quot;男&quot;&#125;
</code></pre>
<p>很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：</p>
<ul>
<li><p>JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</p>
<pre><code class="javascript">var obj = &#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的
var json = &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;; //这是一个 JSON 字符串，本质是一个字符串
</code></pre>
</li>
</ul>
<p><strong>JSON 和 JavaScript 对象互转</strong></p>
<ul>
<li><p>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</p>
<pre><code class="javascript">var obj = JSON.parse(&#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;); 
//结果是 &#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;
</code></pre>
</li>
<li><p>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</p>
<pre><code class="javascript">var json = JSON.stringify(&#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;);
//结果是 &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;
</code></pre>
</li>
</ul>
<p><strong>代码测试</strong></p>
<ol>
<li><p>新建一个module ，springmvc-05-json ， 添加web的支持</p>
</li>
<li><p>在web目录下新建一个 json-1.html ， 编写测试内容</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;JSON_秦疆&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
//编写一个js的对象
var user = &#123;
 name:&quot;成博&quot;,
 age:3,
 sex:&quot;男&quot;
&#125;;
//将js对象转换成json字符串
var str = JSON.stringify(user);
console.log(str);

//将json字符串转换为js对象
var user2 = JSON.parse(str);
console.log(user2.age,user2.name,user2.sex);

&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>在IDEA中使用浏览器打开，查看控制台输出！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331213612113-1624858159.png" alt="img"></p>
</li>
</ol>
<h3 id="Controller返回JSON数据"><a href="#Controller返回JSON数据" class="headerlink" title="Controller返回JSON数据"></a>Controller返回JSON数据</h3><h3 id="1-jackson"><a href="#1-jackson" class="headerlink" title="1.jackson"></a>1.jackson</h3><ul>
<li><p>Jackson应该是目前比较好的json解析工具了</p>
</li>
<li><p>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。</p>
</li>
<li><p>我们这里使用Jackson，使用它需要导入它的jar包；</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.10.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>配置SpringMVC需要的配置<br><strong>web.xml</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--1.注册servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!--所有请求都会被springmvc拦截 --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

&lt;/web-app&gt;
</code></pre>
</li>
</ul>
<p><strong>springmvc-servlet.xml</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li><p>我们随便编写一个User的实体类，然后我们去编写我们的测试Controller；</p>
<pre><code class="java">package com.kuang.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

//需要导入lombok
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;

    private String name;
    private int age;
    private String sex;
    
&#125;
</code></pre>
</li>
<li><p>这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法</p>
</li>
</ul>
<p>编写一个Controller；</p>
<pre><code class="java">@Controller
public class UserController &#123;

    @RequestMapping(&quot;/json1&quot;)
    @ResponseBody
    public String json1() throws JsonProcessingException &#123;
        //创建一个jackson的对象映射器，用来解析数据
        ObjectMapper mapper = new ObjectMapper();
        //创建一个对象
        User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
        //将我们的对象解析成为json格式
        String str = mapper.writeValueAsString(user);
        //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便
        return str;
    &#125;

&#125;
</code></pre>
<ul>
<li>配置Tomcat ， 启动测试一下！</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a>:8080&#x2F;json1</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331213642133-500236017.png" alt="img"></p>
<ul>
<li><p>发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型；</p>
</li>
<li><p>通过@RequestMaping的produces属性来实现，修改下代码</p>
<pre><code class="java">//produces:指定响应体返回类型和编码
@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)
</code></pre>
</li>
<li><p>再次测试， <a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a>:8080&#x2F;json1 ， 乱码问题OK！</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331213702188-1592450222.png" alt="img"></p>
</li>
</ul>
<p>【注意：使用json记得处理乱码问题】</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p><strong>乱码统一解决</strong></p>
<p>上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！</p>
<p>我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！</p>
<pre><code class="xml"> &lt;!--JSON乱码问题配置--&gt;
&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<p><strong>返回json字符串统一解决</strong></p>
<p>在类上直接使用 <strong>@RestController</strong> ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！</p>
<pre><code class="java">@RestController
public class UserController &#123;

    //produces:指定响应体返回类型和编码
    @RequestMapping(value = &quot;/json1&quot;)
    public String json1() throws JsonProcessingException &#123;
        //创建一个jackson的对象映射器，用来解析数据
        ObjectMapper mapper = new ObjectMapper();
        //创建一个对象
        User user = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
        //将我们的对象解析成为json格式
        String str = mapper.writeValueAsString(user);
        //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便
        return str;
    &#125;

&#125;
</code></pre>
<p>启动tomcat测试，结果都正常输出！</p>
<h3 id="测试集合输出"><a href="#测试集合输出" class="headerlink" title="测试集合输出"></a>测试集合输出</h3><p>增加一个新的方法</p>
<pre><code class="java">@RequestMapping(&quot;/json2&quot;)
@ResponseBody
public String json2() throws JsonProcessingException &#123;

    //创建一个jackson的对象映射器，用来解析数据
    ObjectMapper mapper = new ObjectMapper();
    //创建一个对象
    User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
    User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);
    User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);
    User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);
    List&lt;User&gt; list = new ArrayList&lt;User&gt;();
    list.add(user1);
    list.add(user2);
    list.add(user3);
    list.add(user4);

    //将我们的对象解析成为json格式
    String str = mapper.writeValueAsString(list);
    return str;
&#125;
</code></pre>
<p>运行结果 : 十分完美，没有任何问题！</p>
<h3 id="输出时间对象"><a href="#输出时间对象" class="headerlink" title="输出时间对象"></a>输出时间对象</h3><p>增加一个新的方法</p>
<pre><code class="java">@RequestMapping(&quot;/json3&quot;)
public String json3() throws JsonProcessingException &#123;

    ObjectMapper mapper = new ObjectMapper();

    //创建时间一个对象，java.util.Date
    Date date = new Date();
    //将我们的对象解析成为json格式
    String str = mapper.writeValueAsString(date);
    return str;
&#125;
</code></pre>
<p>运行结果 :</p>
<ul>
<li>默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！</li>
<li>Jackson 默认是会把时间转成timestamps形式</li>
</ul>
<p><strong>解决方案：取消timestamps形式 ， 自定义时间格式</strong></p>
<pre><code class="java">@RequestMapping(&quot;/json4&quot;)
public String json4() throws JsonProcessingException &#123;

    ObjectMapper mapper = new ObjectMapper();

    //不使用时间戳的方式
    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
    //自定义日期格式对象
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
    //指定日期格式
    mapper.setDateFormat(sdf);

    Date date = new Date();
    String str = mapper.writeValueAsString(date);

    return str;
&#125;
</code></pre>
<p>运行结果 : 成功的输出了时间！</p>
<p><em><strong>时间戳格式化，老手艺不能丢</strong></em></p>
<pre><code class="java">  @RequestMapping(&quot;/json6&quot;)
    @ResponseBody
    public String json6() throws JsonProcessingException &#123;

        ObjectMapper mapper = new ObjectMapper();
        Date date = new Date();
        //自定义日期的格式
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        // objectMapper,时间解析后的默认格式为: Timestamp, 时间裁
        return mapper.writeValueAsString(sdf.format(date));

    &#125;
</code></pre>
<h3 id="抽取为工具类"><a href="#抽取为工具类" class="headerlink" title="抽取为工具类"></a>抽取为工具类</h3><p><strong>如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下</strong></p>
<pre><code class="java">package com.kuang.utils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

import java.text.SimpleDateFormat;

public class JsonUtils &#123;
    
    public static String getJson(Object object) &#123;
        return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);
    &#125;

    public static String getJson(Object object,String dateFormat) &#123;
        ObjectMapper mapper = new ObjectMapper();
        //不使用时间差的方式
        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        //自定义日期格式对象
        SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);
        //指定日期格式
        mapper.setDateFormat(sdf);
        try &#123;
            return mapper.writeValueAsString(object);
        &#125; catch (JsonProcessingException e) &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<p>我们使用工具类，代码就更加简洁了！</p>
<pre><code class="java">@RequestMapping(&quot;/json5&quot;)
public String json5() throws JsonProcessingException &#123;
    Date date = new Date();
    String json = JsonUtils.getJson(date);
    return json;
&#125;
</code></pre>
<p>大工告成！完美！</p>
<h3 id="2-FastJson"><a href="#2-FastJson" class="headerlink" title="2.FastJson"></a>2.FastJson</h3><p>fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。</p>
<p>fastjson 的 pom依赖！</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.60&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>fastjson 三个主要的类：</p>
<ul>
<li>【JSONObject 代表 json 对象 】<ul>
<li>JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。</li>
<li>JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</li>
</ul>
</li>
<li>【JSONArray 代表 json 对象数组】<ul>
<li>内部是有List接口中的方法来完成操作的。</li>
</ul>
</li>
<li>【JSON 代表 JSONObject和JSONArray的转化】<ul>
<li>JSON类源码分析与使用</li>
<li>仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。</li>
</ul>
</li>
</ul>
<p><strong>代码测试，我们新建一个FastJsonDemo 类</strong></p>
<pre><code class="java">package com.kuang.controller;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.kuang.pojo.User;

import java.util.ArrayList;
import java.util.List;

public class FastJsonDemo &#123;
    public static void main(String[] args) &#123;
        //创建一个对象
        User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
        User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);
        User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);
        User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);
        List&lt;User&gt; list = new ArrayList&lt;User&gt;();
        list.add(user1);
        list.add(user2);
        list.add(user3);
        list.add(user4);

        System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);
        String str1 = JSON.toJSONString(list);
        System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1);
        String str2 = JSON.toJSONString(user1);
        System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2);

        System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);
        User jp_user1=JSON.parseObject(str2,User.class);
        System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1);

        System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);
        JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);
        System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;));

        System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);
        User to_java_user = JSON.toJavaObject(jsonObject1, User.class);
        System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user);
    &#125;
&#125;
</code></pre>
<p>例题：</p>
<pre><code class="java">@RequestMapping(&quot;/json8&quot;)
    @ResponseBody
    public String json8() throws JsonProcessingException &#123;

        //创建一个对象
        User user1 = new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);
        User user2 = new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);
        User user3 = new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);
        User user4 = new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);
        List&lt;User&gt; list = new ArrayList&lt;User&gt;();
        list.add(user1);
        list.add(user2);
        list.add(user3);
        list.add(user4);

        //将我们的对象解析成为json格式
        String str1 = JSON.toJSONString(list);
        return str1;
    &#125;
</code></pre>
<p>测试：</p>
<p><a target="_blank" rel="noopener" href="http://localhost/">http://localhost</a>:8080&#x2F;json8</p>
<p><img src="https://cdn.jsdelivr.net/gh/ISDAY/FigureBed/1905053-20200331213729633-854108693.png" alt="img"></p>
<p>这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！</p>
<h2 id="11、Ajax技术"><a href="#11、Ajax技术" class="headerlink" title="11、Ajax技术"></a>11、Ajax技术</h2><h3 id="11-1、AJAX初体验"><a href="#11-1、AJAX初体验" class="headerlink" title="11.1、AJAX初体验"></a>11.1、AJAX初体验</h3><p>异步可理解为局部刷新，同步指需要按部就班地完成一整套流程</p>
<ul>
<li><strong>AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</strong></li>
<li>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>
<li><strong>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</strong></li>
<li>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。</li>
<li>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</li>
<li>就和国内百度的搜索框一样：<br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3986165583.png" alt="1570200763067.png"></li>
<li>传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。</li>
<li>使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</li>
<li>使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。</li>
</ul>
<h3 id="伪造Ajax"><a href="#伪造Ajax" class="headerlink" title="伪造Ajax"></a>伪造Ajax</h3><p>我们可以使用前端的一个标签来伪造一个ajax的样子。 iframe标签</p>
<ol>
<li><p>新建一个module ： sspringmvc-06-ajax ， 导入web支持！</p>
</li>
<li><p>编写一个 ajax-frame.html 使用 iframe 测试，感受下效果</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head lang=&quot;en&quot;&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;kuangshen&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
window.onload = function()&#123;
 var myDate = new Date();
 document.getElementById(&#39;currentTime&#39;).innerText = myDate.getTime();
&#125;;

function LoadPage()&#123;
 var targetUrl =  document.getElementById(&#39;url&#39;).value;
 console.log(targetUrl);
 document.getElementById(&quot;iframePosition&quot;).src = targetUrl;
&#125;

&lt;/script&gt;

&lt;div&gt;
&lt;p&gt;请输入要加载的地址：&lt;span id=&quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;
 &lt;input id=&quot;url&quot; type=&quot;text&quot; value=&quot;https://www.baidu.com/&quot;/&gt;
 &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;LoadPage()&quot;&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;
&lt;h3&gt;加载页面位置：&lt;/h3&gt;
&lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 500px;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>使用IDEA开浏览器测试一下！</p>
</li>
</ol>
<p><strong>利用AJAX可以做：</strong></p>
<ul>
<li>注册时，输入用户名自动检测用户是否已经存在。</li>
<li>登陆时，提示用户名密码错误</li>
<li>删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。</li>
<li>….等等</li>
</ul>
<h3 id="jQuery-ajax"><a href="#jQuery-ajax" class="headerlink" title="jQuery.ajax"></a>jQuery.ajax</h3><ul>
<li>纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！</li>
<li>Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</li>
<li>jQuery 提供多个与 AJAX 有关的方法。</li>
<li>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</li>
<li>jQuery 不是生产者，而是大自然搬运工。</li>
<li>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</li>
</ul>
<pre><code class="mipsasm">jQuery.ajax(...)
       部分参数：
              url：请求地址
             type：请求方式，GET、POST（1.9.0之后用method）
          headers：请求头
             data：要发送的数据
      contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)
            async：是否异步
          timeout：设置请求超时时间（毫秒）
       beforeSend：发送请求前执行的函数(全局)
         complete：完成之后执行的回调函数(全局)
          success：成功之后执行的回调函数(全局)
            error：失败之后执行的回调函数(全局)
          accepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型
         dataType：将服务器端返回的数据转换成指定类型
            &quot;xml&quot;: 将服务器端返回的内容转换成xml格式
           &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式
           &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。
         &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式
           &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象
          &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数
</code></pre>
<p><strong>我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用</strong></p>
<ol>
<li><p>配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;
    &lt;context:component-scan base-package=&quot;com.kuang.controller&quot;/&gt;
    &lt;mvc:default-servlet-handler /&gt;
    &lt;mvc:annotation-driven /&gt;

    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
</li>
<li><p>编写一个AjaxController</p>
<pre><code class="java">@Controller
public class AjaxController &#123;

    @RequestMapping(&quot;/a1&quot;)
    public void ajax1(String name , HttpServletResponse response) throws IOException &#123;
        if (&quot;admin&quot;.equals(name))&#123;
            response.getWriter().print(&quot;true&quot;);
        &#125;else&#123;
            response.getWriter().print(&quot;false&quot;);
        &#125;
    &#125;

&#125;
</code></pre>
</li>
<li><p>导入jquery ， 可以使用在线的CDN ， 也可以下载导入</p>
<pre><code class="html">&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li><p>编写index.jsp测试</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
    &lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt;
    &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        function a1()&#123;
            $.post(&#123;
                url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;,
                data:&#123;&#39;name&#39;:$(&quot;#txtName&quot;).val()&#125;,
                success:function (data,status) &#123;
                    alert(data);
                    alert(status);
                &#125;
            &#125;);
        &#125;
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;

  &lt;%--onblur：失去焦点触发事件--%&gt;
  用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt;

  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>启动tomcat测试！ 打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！</p>
</li>
</ol>
<hr>
<h3 id="11-2、AJAX异步加载数据"><a href="#11-2、AJAX异步加载数据" class="headerlink" title="11.2、AJAX异步加载数据"></a>11.2、AJAX异步加载数据</h3><h3 id="Springmvc实现"><a href="#Springmvc实现" class="headerlink" title="Springmvc实现"></a>Springmvc实现</h3><p>实体类user</p>
<pre><code class="java">@Data
@AllArgsConstructor
@NoArgsConstructor
public class User &#123;

    private String name;
    private int age;
    private String sex;

&#125;
</code></pre>
<p>我们来获取一个集合对象，展示到前端页面</p>
<pre><code class="java">@RequestMapping(&quot;/a2&quot;)
public List&lt;User&gt; ajax2()&#123;
    List&lt;User&gt; list = new ArrayList&lt;User&gt;();
    list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;));
    list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;));
    list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;));
    return list; //由于@RestController注解，将list转成json格式返回
&#125;
</code></pre>
<p>前端页面</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;获取数据&quot;/&gt;
&lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;姓名&lt;/td&gt;
        &lt;td&gt;年龄&lt;/td&gt;
        &lt;td&gt;性别&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tbody id=&quot;content&quot;&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;

    $(function () &#123;
        $(&quot;#btn&quot;).click(function () &#123;
            $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123;
                console.log(data)
                var html=&quot;&quot;;
                for (var i = 0; i &lt;data.length ; i++) &#123;
                    html+= &quot;&lt;tr&gt;&quot; +
                        &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; +
                        &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; +
                        &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; +
                        &quot;&lt;/tr&gt;&quot;
                &#125;
                $(&quot;#content&quot;).html(html);
            &#125;);
        &#125;)
    &#125;)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>成功实现了数据回显！可以体会一下Ajax的好处！</strong></p>
<h3 id="11-3、AJAX验证用户名体验"><a href="#11-3、AJAX验证用户名体验" class="headerlink" title="11.3、AJAX验证用户名体验"></a>11.3、AJAX验证用户名体验</h3><h3 id="注册提示效果"><a href="#注册提示效果" class="headerlink" title="注册提示效果"></a>注册提示效果</h3><p>我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化</p>
<p>我们写一个Controller</p>
<pre><code class="java">@RequestMapping(&quot;/a3&quot;)
public String ajax3(String name,String pwd)&#123;
    String msg = &quot;&quot;;
    //模拟数据库中存在数据
    if (name!=null)&#123;
        if (&quot;admin&quot;.equals(name))&#123;
            msg = &quot;OK&quot;;
        &#125;else &#123;
            msg = &quot;用户名输入错误&quot;;
        &#125;
    &#125;
    if (pwd!=null)&#123;
        if (&quot;123456&quot;.equals(pwd))&#123;
            msg = &quot;OK&quot;;
        &#125;else &#123;
            msg = &quot;密码输入有误&quot;;
        &#125;
    &#125;
    return msg; //由于@RestController注解，将msg转成json格式返回
&#125;
</code></pre>
<p>前端页面 login.jsp</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;ajax&lt;/title&gt;
    &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;

        function a1()&#123;
            $.post(&#123;
                url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
                data:&#123;&#39;name&#39;:$(&quot;#name&quot;).val()&#125;,
                success:function (data) &#123;
                    if (data.toString()==&#39;OK&#39;)&#123;
                        $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);
                    &#125;else &#123;
                        $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);
                    &#125;
                    $(&quot;#userInfo&quot;).html(data);
                &#125;
            &#125;);
        &#125;
        function a2()&#123;
            $.post(&#123;
                url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;,
                data:&#123;&#39;pwd&#39;:$(&quot;#pwd&quot;).val()&#125;,
                success:function (data) &#123;
                    if (data.toString()==&#39;OK&#39;)&#123;
                        $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);
                    &#125;else &#123;
                        $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);
                    &#125;
                    $(&quot;#pwdInfo&quot;).html(data);
                &#125;
            &#125;);
        &#125;

    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;
    用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt;
    &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
    密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt;
    &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>【记得处理json乱码问题】</p>
<p>测试一下效果，动态请求响应，局部刷新，就是如此！</p>
<p><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/3300712039.png" alt="1570203565381.png"></p>
<h3 id="11-4、补充，自己看看"><a href="#11-4、补充，自己看看" class="headerlink" title="11.4、补充，自己看看"></a>11.4、补充，自己看看</h3><h3 id="获取baidu接口Demo"><a href="#获取baidu接口Demo" class="headerlink" title="获取baidu接口Demo"></a>获取baidu接口Demo</h3><pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
    &lt;title&gt;JSONP百度搜索&lt;/title&gt;
    &lt;style&gt;
        #q&#123;
            width: 500px;
            height: 30px;
            border:1px solid #ddd;
            line-height: 30px;
            display: block;
            margin: 0 auto;
            padding: 0 10px;
            font-size: 14px;
        &#125;
        #ul&#123;
            width: 520px;
            list-style: none;
            margin: 0 auto;
            padding: 0;
            border:1px solid #ddd;
            margin-top: -1px;
            display: none;
        &#125;
        #ul li&#123;
            line-height: 30px;
            padding: 0 10px;
        &#125;
        #ul li:hover&#123;
            background-color: #f60;
            color: #fff;
        &#125;
    &lt;/style&gt;
    &lt;script&gt;

        // 2.步骤二
        // 定义demo函数 (分析接口、数据)
        function demo(data)&#123;
            var Ul = document.getElementById(&#39;ul&#39;);
            var html = &#39;&#39;;
            // 如果搜索数据存在 把内容添加进去
            if (data.s.length) &#123;
                // 隐藏掉的ul显示出来
                Ul.style.display = &#39;block&#39;;
                // 搜索到的数据循环追加到li里
                for(var i = 0;i&lt;data.s.length;i++)&#123;
                    html += &#39;&lt;li&gt;&#39;+data.s[i]+&#39;&lt;/li&gt;&#39;;
                &#125;
                // 循环的li写入ul
                Ul.innerHTML = html;
            &#125;
        &#125;

        // 1.步骤一
        window.onload = function()&#123;
            // 获取输入框和ul
            var Q = document.getElementById(&#39;q&#39;);
            var Ul = document.getElementById(&#39;ul&#39;);

            // 事件鼠标抬起时候
            Q.onkeyup = function()&#123;
                // 如果输入框不等于空
                if (this.value != &#39;&#39;) &#123;
                    // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
                    // 创建标签
                    var script = document.createElement(&#39;script&#39;);
                    //给定要跨域的地址 赋值给src
                    //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址
                    script.src = &#39;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#39;+this.value+&#39;&amp;cb=demo&#39;;
                    // 将组合好的带src的script标签追加到body里
                    document.body.appendChild(script);
                &#125;
            &#125;
        &#125;
    &lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;input type=&quot;text&quot; id=&quot;q&quot; /&gt;
&lt;ul id=&quot;ul&quot;&gt;

&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="12、拦截器"><a href="#12、拦截器" class="headerlink" title="12、拦截器"></a>12、拦截器</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p>
<p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p>
<p><strong>过滤器</strong></p>
<ul>
<li>servlet规范中的一部分，任何java web工程都可以使用</li>
<li>在url-pattern中配置了&#x2F;*之后，可以对所有要访问的资源进行拦截</li>
</ul>
<p><strong>拦截器</strong></p>
<ul>
<li>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li>
<li>拦截器只会拦截访问的控制器方法， 如果访问的是jsp&#x2F;html&#x2F;css&#x2F;image&#x2F;js是不会进行拦截的</li>
</ul>
<h3 id="12-1、自定义拦截器"><a href="#12-1、自定义拦截器" class="headerlink" title="12.1、自定义拦截器"></a>12.1、自定义拦截器</h3><p>那如何实现拦截器呢？</p>
<p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p>
<ol>
<li><p>新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持</p>
</li>
<li><p>配置web.xml 和 springmvc-servlet.xml 文件</p>
</li>
<li><p>编写一个拦截器</p>
<pre><code class="java">package com.kuang.interceptor;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class MyInterceptor implements HandlerInterceptor &#123;

    //在请求处理的方法之前执行
    //如果返回true执行下一个拦截器
    //如果返回false就不执行下一个拦截器
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;
        System.out.println(&quot;------------处理前------------&quot;);
        return true;
    &#125;

    //在请求处理方法执行之后执行
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;------------处理后------------&quot;);
    &#125;

    //在dispatcherServlet处理后执行,做清理工作.
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;
        System.out.println(&quot;------------清理------------&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>在springmvc的配置文件中配置拦截器</p>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/** 包括路径及其子路径--&gt;
        &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
        &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;!--bean配置的就是拦截器--&gt;
        &lt;bean class=&quot;com.kuang.interceptor.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
</li>
<li><p>编写一个Controller，接收请求</p>
<pre><code class="java">package com.kuang.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

//测试拦截器的控制器
@Controller
public class InterceptorController &#123;

    @RequestMapping(&quot;/interceptor&quot;)
    @ResponseBody
    public String testFunction() &#123;
        System.out.println(&quot;控制器中的方法执行了&quot;);
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
</li>
<li><p>前端 index.jsp</p>
<pre><code class="html">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/interceptor&quot;&gt;拦截器测试&lt;/a&gt;
</code></pre>
</li>
<li><p>启动tomcat 测试一下！<br><img src="https://blog.kuangstudy.com/usr/uploads/2019/10/2785405154.png" alt="1570205071233.png"></p>
</li>
</ol>
<h3 id="12-2、验证用户是否登录-认证用户"><a href="#12-2、验证用户是否登录-认证用户" class="headerlink" title="12.2、验证用户是否登录 (认证用户)"></a>12.2、验证用户是否登录 (认证用户)</h3><p><strong>实现思路</strong></p>
<ol>
<li>有一个登陆页面，需要写一个controller访问页面。</li>
<li>登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。<em>返回登陆成功。</em></li>
<li>拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</li>
</ol>
<p><strong>代码编写</strong></p>
<ol>
<li><p>编写一个登陆页面 login.jsp</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;

&lt;h1&gt;登录页面&lt;/h1&gt;
&lt;hr&gt;

&lt;body&gt;
&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot;&gt;
    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;
    密码： &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>编写一个Controller处理请求</p>
<pre><code class="java">package com.kuang.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpSession;

@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController &#123;

    //跳转到登陆页面
    @RequestMapping(&quot;/jumplogin&quot;)
    public String jumpLogin() throws Exception &#123;
        return &quot;login&quot;;
    &#125;

    //跳转到成功页面
    @RequestMapping(&quot;/jumpSuccess&quot;)
    public String jumpSuccess() throws Exception &#123;
        return &quot;success&quot;;
    &#125;

    //登陆提交
    @RequestMapping(&quot;/login&quot;)
    public String login(HttpSession session, String username, String pwd) throws Exception &#123;
        // 向session记录用户身份信息
        System.out.println(&quot;接收前端===&quot;+username);
        session.setAttribute(&quot;user&quot;, username);
        return &quot;success&quot;;
    &#125;

    //退出登陆
    @RequestMapping(&quot;logout&quot;)
    public String logout(HttpSession session) throws Exception &#123;
        // session 过期
        session.invalidate();
        return &quot;login&quot;;
    &#125;
&#125;
</code></pre>
</li>
<li><p>编写一个登陆成功的页面 success.jsp</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;登录成功页面&lt;/h1&gt;
&lt;hr&gt;

$&#123;user&#125;
&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;注销&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！</p>
<pre><code class="jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;h1&gt;首页&lt;/h1&gt;
  &lt;hr&gt;
  &lt;%--登录--%&gt;
  &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumplogin&quot;&gt;登录&lt;/a&gt;
  &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumpSuccess&quot;&gt;成功页面&lt;/a&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>编写用户登录拦截器</p>
<pre><code class="java">package com.kuang.interceptor;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

public class LoginInterceptor implements HandlerInterceptor &#123;

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;
        // 如果是登陆页面则放行
        System.out.println(&quot;uri: &quot; + request.getRequestURI());
        if (request.getRequestURI().contains(&quot;login&quot;)) &#123;
            return true;
        &#125;

        HttpSession session = request.getSession();

        // 如果用户已登陆也放行
        if(session.getAttribute(&quot;user&quot;) != null) &#123;
            return true;
        &#125;

        // 用户没有登陆跳转到登陆页面
        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);
        return false;
    &#125;

    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;

    &#125;
    
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;

    &#125;
&#125;
</code></pre>
</li>
<li><p>在Springmvc的配置文件中注册拦截器</p>
<pre><code class="xml">&lt;!--关于拦截器的配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;bean id=&quot;loginInterceptor&quot; class=&quot;com.kuang.interceptor.LoginInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
</li>
<li><p>再次重启Tomcat测试！</p>
</li>
</ol>
<p><strong>OK，测试登录拦截功能无误.</strong></p>
<h2 id="13、SpringMVC：文件上传和下载"><a href="#13、SpringMVC：文件上传和下载" class="headerlink" title="13、SpringMVC：文件上传和下载"></a>13、SpringMVC：文件上传和下载</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。</p>
<p>前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart&#x2F;form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p>
<p><strong>对表单中的 enctype 属性做个详细的说明：</strong></p>
<ul>
<li>application&#x2F;x-www&#x3D;form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li>
<li>multipart&#x2F;form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li>
<li>text&#x2F;plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li>
</ul>
<pre><code class="html">&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>一旦设置了enctype为multipart&#x2F;form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet&#x2F;JSP程序员上传文件的最佳选择。</p>
<ul>
<li>Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。</li>
<li>而Spring MVC则提供了更简单的封装。</li>
<li>Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。</li>
<li>Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。</li>
</ul>
<h3 id="13-1、文件上传"><a href="#13-1、文件上传" class="headerlink" title="13.1、文件上传"></a>13.1、文件上传</h3><p>一、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包；</p>
<pre><code class="xml">&lt;!--文件上传--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--servlet-api导入高版本的--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>二、配置bean：multipartResolver<br>【<strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong>】</p>
<pre><code class="xml">&lt;!--文件上传配置--&gt;
&lt;bean id=&quot;multipartResolver&quot;  class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;
    &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;
    &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt;
    &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>CommonsMultipartFile 的 常用方法：</p>
<ul>
<li><strong>String getOriginalFilename()：获取上传文件的原名</strong></li>
<li><strong>InputStream getInputStream()：获取文件流</strong></li>
<li><strong>void transferTo(File dest)：将上传文件保存到一个目录文件中</strong></li>
</ul>
<p>我们去实际测试一下</p>
<p>三、编写前端页面</p>
<pre><code class="html">&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;
  &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
  &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>四、<strong>Controller</strong></p>
<pre><code class="java">package com.kuang.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.commons.CommonsMultipartFile;

import javax.servlet.http.HttpServletRequest;
import java.io.*;

@Controller
public class FileController &#123;
    //@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象
    //批量上传CommonsMultipartFile则为数组即可
    @RequestMapping(&quot;/upload&quot;)
    public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123;

        //获取文件名 : file.getOriginalFilename();
        String uploadFileName = file.getOriginalFilename();

        //如果文件名为空，直接回到首页！
        if (&quot;&quot;.equals(uploadFileName))&#123;
            return &quot;redirect:/index.jsp&quot;;
        &#125;
        System.out.println(&quot;上传文件名 : &quot;+uploadFileName);

        //上传路径保存设置
        String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
        //如果路径不存在，创建一个
        File realPath = new File(path);
        if (!realPath.exists())&#123;
            realPath.mkdir();
        &#125;
        System.out.println(&quot;上传文件保存地址：&quot;+realPath);

        InputStream is = file.getInputStream(); //文件输入流
        OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流

        //读取写出
        int len=0;
        byte[] buffer = new byte[1024];
        while ((len=is.read(buffer))!=-1)&#123;
            os.write(buffer,0,len);
            os.flush();
        &#125;
        os.close();
        is.close();
        return &quot;redirect:/index.jsp&quot;;
    &#125;
&#125;
</code></pre>
<p>五、测试上传文件，OK！</p>
<h3 id="采用file-Transto-来保存上传的文件"><a href="#采用file-Transto-来保存上传的文件" class="headerlink" title="采用file.Transto 来保存上传的文件"></a>采用file.Transto 来保存上传的文件</h3><ol>
<li><p>编写Controller</p>
<pre><code class="java">/*
 * 采用file.Transto 来保存上传的文件
 */
@RequestMapping(&quot;/upload2&quot;)
public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123;

    //上传路径保存设置
    String path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    File realPath = new File(path);
    if (!realPath.exists())&#123;
        realPath.mkdir();
    &#125;
    //上传文件地址
    System.out.println(&quot;上传文件保存地址：&quot;+realPath);

    //通过CommonsMultipartFile的方法直接写文件（注意这个时候）
    file.transferTo(new File(realPath +&quot;/&quot;+ file.getOriginalFilename()));

    return &quot;redirect:/index.jsp&quot;;
&#125;
</code></pre>
</li>
<li><p>前端表单提交地址修改</p>
</li>
<li><p>访问提交测试，OK！</p>
</li>
</ol>
<h3 id="13-2、文件下载"><a href="#13-2、文件下载" class="headerlink" title="13.2、文件下载"></a>13.2、文件下载</h3><p>文件下载步骤：</p>
<ol>
<li>设置 response 响应头</li>
<li>读取文件 – InputStream</li>
<li>写出文件 – OutputStream</li>
<li>执行操作</li>
<li>关闭流 （先开后关）</li>
</ol>
<p>代码实现：</p>
<pre><code class="java">@RequestMapping(value=&quot;/download&quot;)
public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception&#123;
    //要下载的图片地址
    String  path = request.getServletContext().getRealPath(&quot;/upload&quot;);
    String  fileName = &quot;基础语法.jpg&quot;;

    //1、设置response 响应头
    response.reset(); //设置页面不缓存,清空buffer
    response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码
    response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据
    //设置响应头
    response.setHeader(&quot;Content-Disposition&quot;,
            &quot;attachment;fileName=&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;));

    File file = new File(path,fileName);
    //2、 读取文件--输入流
    InputStream input=new FileInputStream(file);
    //3、 写出文件--输出流
    OutputStream out = response.getOutputStream();

    byte[] buff =new byte[1024];
    int index=0;
    //4、执行 写出操作
    while((index= input.read(buff))!= -1)&#123;
        out.write(buff, 0, index);
        out.flush();
    &#125;
    out.close();
    input.close();
    return null;
&#125;
</code></pre>
<p>前端</p>
<pre><code class="html">&lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;
</code></pre>
<p>测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了!</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #ff7d73">
                SSM
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/SpringMVC/" style="color: #03a9f4">
                SpringMVC
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/SpringMVC_狂神说/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/18/Maven的安装和配置/">
        <h2 class="post-title">Maven</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/SSM/">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                SSM
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="MAVEN"><a href="#MAVEN" class="headerlink" title="MAVEN"></a>MAVEN</h1><ol>
<li><h4 id="下载："><a href="#下载：" class="headerlink" title="下载："></a><strong>下载：</strong></h4><ul>
<li><strong>官网：<a target="_blank" rel="noopener" href="https://maven.apache.org/">https://maven.apache.org/</a></strong></li>
<li><strong>点击Download下载</strong></li>
<li><img src="https://user-images.githubusercontent.com/77709357/175769287-595f3cf2-e3c4-4ba1-bebd-d576a61c4b37.png" alt="image-20220625173640440"></li>
<li><img src="https://user-images.githubusercontent.com/77709357/175769357-0b6727c4-2c11-4a27-97fe-9ff29c479da6.png" alt="image-20220625173745475"></li>
</ul>
</li>
<li><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h4><ul>
<li><strong>maven压缩包解压到一个没有中文，空格或其他特殊字符的文件夹内即可使用。</strong></li>
<li><img src="https://user-images.githubusercontent.com/77709357/175769418-01750bb4-c0a1-47ec-95b6-7184dbaa4a8b.png" alt="image-20220625174341793"></li>
</ul>
</li>
<li><h4 id="配置MAVEN-HOME"><a href="#配置MAVEN-HOME" class="headerlink" title="配置MAVEN_HOME"></a>配置MAVEN_HOME</h4><ol>
<li><p><strong>maven的使用是在jdk的基础上，所以电脑必须有jdk</strong></p>
</li>
<li><p><strong>新增环境变量：MAVEN_HOME</strong><img src="https://user-images.githubusercontent.com/77709357/175769442-f93e6a7f-123e-4460-9ff6-388223657c03.png" alt="image-20220625175015879"></p>
</li>
<li><p><strong>在系统变量点击新建</strong><img src="https://user-images.githubusercontent.com/77709357/175769488-39f026aa-59b0-4277-989b-54846d954605.png" alt="image-20220625175235990"><br> <img src="https://user-images.githubusercontent.com/77709357/175769567-8d1d8b0b-bab9-4a5e-bd09-cff98b916450.png" alt="image-20220625175305040"></p>
<p>  <img src="https://user-images.githubusercontent.com/77709357/175769580-1d4f97df-3ff8-4b11-9b85-5a10ca874d6b.png" alt="image-20220625175410598"></p>
</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/77709357/175769596-5c24e6ac-0062-4d41-aae8-d11487ed19f8.png" alt="image-20220625175448147"></p>
<ol start="4">
<li><p><strong>在path环境变量中添加：%MAVEN_HOME%\bin</strong><br><strong>找到环境变量配置界面</strong></p>
<p> <img src="https://user-images.githubusercontent.com/77709357/175769614-12c7741c-397c-4be4-980f-3ea2f62a0b17.png" alt="image-20220625175726037"></p>
<p> <img src="https://user-images.githubusercontent.com/77709357/175769627-8be30da1-5e5d-4acd-b73a-3a0cfc06818f.png" alt="image-20220625175804334"></p>
</li>
<li><p><strong>测试：按住win+R 输入cmd，进入黑窗口控制台。输入命令： mvn -v</strong><br><strong>如果出现以下maven的版本信息，则说明maven的安装与环境变量的配置均正确；</strong></p>
</li>
</ol>
</li>
<li><h4 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h4><ul>
<li><p><strong>maven的仓库可以分为3种：</strong></p>
<p><img src="https://user-images.githubusercontent.com/77709357/175769640-df6694a0-cae0-450f-91a2-49448088bdcb.png" alt="image-20220625180124043"></p>
<ol>
<li><p><strong>一：配置本地仓库</strong><br><strong>一般情况下，我们需要自己重新设置本地仓库的地址，设置方法如下：</strong></p>
<p> <strong>第一步：在maven的安装目录下创建一个repository文件夹（一般习惯将仓库地址和maven安装目录放置在一起）</strong><img src="https://user-images.githubusercontent.com/77709357/175769648-6ca74ffd-1bb2-469d-abe3-906ad18b3076.png" alt="image-20220625180404372"></p>
<p><strong>第二步：在核心配置文件setting.xml中，将仓库存放的位置设置成：D:\WorkSpace\apache-maven-3.6.1-bin\apache-maven-3.6.1\repository（以自己的安装路径为准）</strong></p>
<p><strong>本地仓库的位置是通过maven的核心配置文件（settings.xml）来配置的。settings.xml文件位于maven安装目录：…\apache-maven-3.6.1\conf\settings.xml 。</strong></p>
<p> <img src="https://user-images.githubusercontent.com/77709357/175769661-1c59abd0-db5f-49b4-b7d8-3321c9bc8aa3.png" alt="image-20220625180735997"></p>
</li>
<li><p><strong>二： 配置私服</strong></p>
<p><strong>打开settins.xml文件，找到<mirrors>标签节点，在这个标签中添加一些配置信息中的任意一个：</strong></p>
<p>【<strong>阿里云私服</strong>】</p>
<pre><code class="xml">&lt;mirror&gt;
     &lt;id&gt;nexus-aliyun&lt;/id&gt;
     &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
     &lt;name&gt;Nexus aliyun&lt;/name&gt;
     &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
 &lt;/mirror&gt;
</code></pre>
<p> <img src="https://user-images.githubusercontent.com/77709357/175769730-8f1877ca-cc54-4620-a9d3-db8df5950d72.png" alt="image-20220625181135633"></p>
</li>
</ol>
</li>
</ul>
<p>​</p>
</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/maven/" style="color: #00a596">
                maven
            </a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/SSM/" style="color: #00a596">
                SSM
            </a>
        </span>
        
    </div>
    <a href="/2022/09/18/Maven的安装和配置/" class="go-post">阅读全文</a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
    </div>
    <div class="next">
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="avatar/avatar.png " alt="avatar">
        </div>
        <div class="name">
            ISDAY
        </div>
        <div class="descriptions">
            
            <div class="description">
                这里的都是我的......
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/arukione,">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://twitter.com/korilin_dev">
                    <i class="fa-brands fa-twitter fa-fw"></i>
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2022 ISDAY
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @ISDAY
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>

    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>